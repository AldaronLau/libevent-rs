/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const EVENT__NUMERIC_VERSION: u32 = 33622784;
pub const EVENT__PACKAGE_VERSION: &'static [u8; 7usize] = b"2.1.11\0";
pub const EVENT__VERSION_MAJOR: u32 = 2;
pub const EVENT__VERSION_MINOR: u32 = 1;
pub const EVENT__VERSION_PATCH: u32 = 11;
pub const EVENT__VERSION: &'static [u8; 14usize] = b"2.1.11-stable\0";
pub const EVENT__PACKAGE: &'static [u8; 9usize] = b"libevent\0";
pub const EVENT__PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\0";
pub const EVENT__PACKAGE_NAME: &'static [u8; 1usize] = b"\0";
pub const EVENT__PACKAGE_STRING: &'static [u8; 1usize] = b"\0";
pub const EVENT__PACKAGE_TARNAME: &'static [u8; 1usize] = b"\0";
pub const EVENT__HAVE_ACCEPT4: u32 = 1;
pub const EVENT__DNS_USE_CPU_CLOCK_FOR_ID: u32 = 1;
pub const EVENT__HAVE_ARPA_INET_H: u32 = 1;
pub const EVENT__HAVE_CLOCK_GETTIME: u32 = 1;
pub const EVENT__HAVE_DECL_CTL_KERN: u32 = 1;
pub const EVENT__HAVE_DECL_KERN_ARND: u32 = 0;
pub const EVENT__HAVE_DECL_KERN_RANDOM: u32 = 1;
pub const EVENT__HAVE_DECL_RANDOM_UUID: u32 = 1;
pub const EVENT__HAVE_NETDB_H: u32 = 1;
pub const EVENT__HAVE_FD_MASK: u32 = 1;
pub const EVENT__HAVE_TAILQFOREACH: u32 = 1;
pub const EVENT__HAVE_DLFCN_H: u32 = 1;
pub const EVENT__HAVE_EPOLL: u32 = 1;
pub const EVENT__HAVE_EPOLL_CREATE1: u32 = 1;
pub const EVENT__HAVE_EPOLL_CTL: u32 = 1;
pub const EVENT__HAVE_EVENTFD: u32 = 1;
pub const EVENT__HAVE_FCNTL: u32 = 1;
pub const EVENT__HAVE_FCNTL_H: u32 = 1;
pub const EVENT__HAVE_GETADDRINFO: u32 = 1;
pub const EVENT__HAVE_GETEGID: u32 = 1;
pub const EVENT__HAVE_GETEUID: u32 = 1;
pub const EVENT__HAVE_GETHOSTBYNAME_R: u32 = 1;
pub const EVENT__HAVE_GETHOSTBYNAME_R_6_ARG: u32 = 1;
pub const EVENT__HAVE_GETIFADDRS: u32 = 1;
pub const EVENT__HAVE_GETNAMEINFO: u32 = 1;
pub const EVENT__HAVE_GETPROTOBYNUMBER: u32 = 1;
pub const EVENT__HAVE_GETSERVBYNAME: u32 = 1;
pub const EVENT__HAVE_GETTIMEOFDAY: u32 = 1;
pub const EVENT__HAVE_IFADDRS_H: u32 = 1;
pub const EVENT__HAVE_INET_NTOP: u32 = 1;
pub const EVENT__HAVE_INET_PTON: u32 = 1;
pub const EVENT__HAVE_INTTYPES_H: u32 = 1;
pub const EVENT__HAVE_MEMORY_H: u32 = 1;
pub const EVENT__HAVE_MMAP: u32 = 1;
pub const EVENT__HAVE_NANOSLEEP: u32 = 1;
pub const EVENT__HAVE_USLEEP: u32 = 1;
pub const EVENT__HAVE_NETINET_IN_H: u32 = 1;
pub const EVENT__HAVE_NETINET_TCP_H: u32 = 1;
pub const EVENT__HAVE_SYS_UN_H: u32 = 1;
pub const EVENT__HAVE_OPENSSL: u32 = 1;
pub const EVENT__HAVE_PIPE: u32 = 1;
pub const EVENT__HAVE_PIPE2: u32 = 1;
pub const EVENT__HAVE_POLL: u32 = 1;
pub const EVENT__HAVE_POLL_H: u32 = 1;
pub const EVENT__HAVE_PTHREADS: u32 = 1;
pub const EVENT__HAVE_PUTENV: u32 = 1;
pub const EVENT__HAVE_SA_FAMILY_T: u32 = 1;
pub const EVENT__HAVE_SELECT: u32 = 1;
pub const EVENT__HAVE_SETENV: u32 = 1;
pub const EVENT__HAVE_SETFD: u32 = 1;
pub const EVENT__HAVE_SETRLIMIT: u32 = 1;
pub const EVENT__HAVE_SENDFILE: u32 = 1;
pub const EVENT__HAVE_SIGACTION: u32 = 1;
pub const EVENT__HAVE_SIGNAL: u32 = 1;
pub const EVENT__HAVE_SPLICE: u32 = 1;
pub const EVENT__HAVE_STDARG_H: u32 = 1;
pub const EVENT__HAVE_STDDEF_H: u32 = 1;
pub const EVENT__HAVE_STDINT_H: u32 = 1;
pub const EVENT__HAVE_STDLIB_H: u32 = 1;
pub const EVENT__HAVE_STRINGS_H: u32 = 1;
pub const EVENT__HAVE_STRING_H: u32 = 1;
pub const EVENT__HAVE_STRSEP: u32 = 1;
pub const EVENT__HAVE_STRTOK_R: u32 = 1;
pub const EVENT__HAVE_STRTOLL: u32 = 1;
pub const EVENT__HAVE_STRUCT_ADDRINFO: u32 = 1;
pub const EVENT__HAVE_STRUCT_IN6_ADDR: u32 = 1;
pub const EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR16: u32 = 1;
pub const EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR32: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_IN6: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_UN: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_STORAGE: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY: u32 = 1;
pub const EVENT__HAVE_STRUCT_LINGER: u32 = 1;
pub const EVENT__HAVE_SYSCTL: u32 = 1;
pub const EVENT__HAVE_SYS_EPOLL_H: u32 = 1;
pub const EVENT__HAVE_SYS_EVENTFD_H: u32 = 1;
pub const EVENT__HAVE_SYS_IOCTL_H: u32 = 1;
pub const EVENT__HAVE_SYS_MMAN_H: u32 = 1;
pub const EVENT__HAVE_SYS_PARAM_H: u32 = 1;
pub const EVENT__HAVE_SYS_QUEUE_H: u32 = 1;
pub const EVENT__HAVE_SYS_RESOURCE_H: u32 = 1;
pub const EVENT__HAVE_SYS_SELECT_H: u32 = 1;
pub const EVENT__HAVE_SYS_SENDFILE_H: u32 = 1;
pub const EVENT__HAVE_SYS_SOCKET_H: u32 = 1;
pub const EVENT__HAVE_SYS_STAT_H: u32 = 1;
pub const EVENT__HAVE_SYS_SYSCTL_H: u32 = 1;
pub const EVENT__HAVE_SYS_TIMERFD_H: u32 = 1;
pub const EVENT__HAVE_SYS_TIME_H: u32 = 1;
pub const EVENT__HAVE_SYS_TYPES_H: u32 = 1;
pub const EVENT__HAVE_SYS_UIO_H: u32 = 1;
pub const EVENT__HAVE_SYS_WAIT_H: u32 = 1;
pub const EVENT__HAVE_ERRNO_H: u32 = 1;
pub const EVENT__HAVE_TIMERFD_CREATE: u32 = 1;
pub const EVENT__HAVE_UINT8_T: u32 = 1;
pub const EVENT__HAVE_UINT16_T: u32 = 1;
pub const EVENT__HAVE_UINT32_T: u32 = 1;
pub const EVENT__HAVE_UINT64_T: u32 = 1;
pub const EVENT__HAVE_UINTPTR_T: u32 = 1;
pub const EVENT__HAVE_UMASK: u32 = 1;
pub const EVENT__HAVE_UNISTD_H: u32 = 1;
pub const EVENT__HAVE_UNSETENV: u32 = 1;
pub const EVENT__HAVE_VASPRINTF: u32 = 1;
pub const EVENT__SIZEOF_PTHREAD_T: u32 = 8;
pub const EVENT__SIZEOF_INT: u32 = 4;
pub const EVENT__SIZEOF_LONG: u32 = 8;
pub const EVENT__SIZEOF_LONG_LONG: u32 = 8;
pub const EVENT__SIZEOF_OFF_T: u32 = 8;
pub const EVENT__SIZEOF_SSIZE_T: u32 = 8;
pub const EVENT__SIZEOF_SHORT: u32 = 2;
pub const EVENT__SIZEOF_SIZE_T: u32 = 8;
pub const EVENT__SIZEOF_SOCKLEN_T: u32 = 4;
pub const EVENT__SIZEOF_VOID_P: u32 = 8;
pub const EVENT__HAVE___func__: u32 = 1;
pub const EVENT__HAVE___FUNCTION__: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _NETDB_H: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MAX: u32 = 45;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MAX: u32 = 45;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 128;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _RPC_NETDB_H: u32 = 1;
pub const _PATH_HEQUIV: &'static [u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &'static [u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &'static [u8; 14usize] = b"/etc/networks\0";
pub const _PATH_NSSWITCH_CONF: &'static [u8; 19usize] = b"/etc/nsswitch.conf\0";
pub const _PATH_PROTOCOLS: &'static [u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &'static [u8; 14usize] = b"/etc/services\0";
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const NO_ADDRESS: u32 = 4;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const AI_NUMERICSERV: u32 = 1024;
pub const EAI_BADFLAGS: i32 = -1;
pub const EAI_NONAME: i32 = -2;
pub const EAI_AGAIN: i32 = -3;
pub const EAI_FAIL: i32 = -4;
pub const EAI_FAMILY: i32 = -6;
pub const EAI_SOCKTYPE: i32 = -7;
pub const EAI_SERVICE: i32 = -8;
pub const EAI_MEMORY: i32 = -10;
pub const EAI_SYSTEM: i32 = -11;
pub const EAI_OVERFLOW: i32 = -12;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NUMERICHOST: u32 = 1;
pub const NI_NUMERICSERV: u32 = 2;
pub const NI_NOFQDN: u32 = 4;
pub const NI_NAMEREQD: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const EV_UINT32_MAX: u32 = 4294967295;
pub const EV_INT32_MAX: u32 = 2147483647;
pub const EV_INT32_MIN: i32 = -2147483648;
pub const EV_UINT16_MAX: u32 = 65535;
pub const EV_INT16_MIN: i32 = -32768;
pub const EV_INT16_MAX: u32 = 32767;
pub const EV_UINT8_MAX: u32 = 255;
pub const EV_INT8_MAX: u32 = 127;
pub const EV_INT8_MIN: i32 = -128;
pub const EV_MONOT_PRECISE: u32 = 1;
pub const EV_MONOT_FALLBACK: u32 = 2;
pub const EVUTIL_INVALID_SOCKET: i32 = -1;
pub const EVUTIL_EAI_ADDRFAMILY: i32 = -901;
pub const EVUTIL_EAI_AGAIN: i32 = -3;
pub const EVUTIL_EAI_BADFLAGS: i32 = -1;
pub const EVUTIL_EAI_FAIL: i32 = -4;
pub const EVUTIL_EAI_FAMILY: i32 = -6;
pub const EVUTIL_EAI_MEMORY: i32 = -10;
pub const EVUTIL_EAI_NODATA: i32 = -907;
pub const EVUTIL_EAI_NONAME: i32 = -2;
pub const EVUTIL_EAI_SERVICE: i32 = -8;
pub const EVUTIL_EAI_SOCKTYPE: i32 = -7;
pub const EVUTIL_EAI_SYSTEM: i32 = -11;
pub const EVUTIL_EAI_CANCEL: i32 = -90001;
pub const EVUTIL_AI_PASSIVE: u32 = 1;
pub const EVUTIL_AI_CANONNAME: u32 = 2;
pub const EVUTIL_AI_NUMERICHOST: u32 = 4;
pub const EVUTIL_AI_NUMERICSERV: u32 = 1024;
pub const EVUTIL_AI_V4MAPPED: u32 = 8;
pub const EVUTIL_AI_ALL: u32 = 16;
pub const EVUTIL_AI_ADDRCONFIG: u32 = 32;
pub const EVLIST_TIMEOUT: u32 = 1;
pub const EVLIST_INSERTED: u32 = 2;
pub const EVLIST_SIGNAL: u32 = 4;
pub const EVLIST_ACTIVE: u32 = 8;
pub const EVLIST_INTERNAL: u32 = 16;
pub const EVLIST_ACTIVE_LATER: u32 = 32;
pub const EVLIST_FINALIZING: u32 = 64;
pub const EVLIST_INIT: u32 = 128;
pub const EVLIST_ALL: u32 = 255;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const EVENT_BASE_COUNT_ACTIVE: u32 = 1;
pub const EVENT_BASE_COUNT_VIRTUAL: u32 = 2;
pub const EVENT_BASE_COUNT_ADDED: u32 = 4;
pub const EVENT_LOG_DEBUG: u32 = 0;
pub const EVENT_LOG_MSG: u32 = 1;
pub const EVENT_LOG_WARN: u32 = 2;
pub const EVENT_LOG_ERR: u32 = 3;
pub const _EVENT_LOG_DEBUG: u32 = 0;
pub const _EVENT_LOG_MSG: u32 = 1;
pub const _EVENT_LOG_WARN: u32 = 2;
pub const _EVENT_LOG_ERR: u32 = 3;
pub const EVENT_DBG_ALL: u32 = 4294967295;
pub const EVENT_DBG_NONE: u32 = 0;
pub const EVLOOP_ONCE: u32 = 1;
pub const EVLOOP_NONBLOCK: u32 = 2;
pub const EVLOOP_NO_EXIT_ON_EMPTY: u32 = 4;
pub const EV_TIMEOUT: u32 = 1;
pub const EV_READ: u32 = 2;
pub const EV_WRITE: u32 = 4;
pub const EV_SIGNAL: u32 = 8;
pub const EV_PERSIST: u32 = 16;
pub const EV_ET: u32 = 32;
pub const EV_FINALIZE: u32 = 64;
pub const EV_CLOSED: u32 = 128;
pub const LIBEVENT_VERSION: &'static [u8; 14usize] = b"2.1.11-stable\0";
pub const LIBEVENT_VERSION_NUMBER: u32 = 33622784;
pub const EVENT_MAX_PRIORITIES: u32 = 256;
pub const _SYS_UIO_H: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const EVBUFFER_FLAG_DRAINS_TO_FD: u32 = 1;
pub const EVBUF_FS_CLOSE_ON_FREE: u32 = 1;
pub const EVBUF_FS_DISABLE_MMAP: u32 = 2;
pub const EVBUF_FS_DISABLE_SENDFILE: u32 = 4;
pub const EVBUF_FS_DISABLE_LOCKING: u32 = 8;
pub const EVBUFFER_CB_ENABLED: u32 = 1;
pub const BEV_EVENT_READING: u32 = 1;
pub const BEV_EVENT_WRITING: u32 = 2;
pub const BEV_EVENT_EOF: u32 = 16;
pub const BEV_EVENT_ERROR: u32 = 32;
pub const BEV_EVENT_TIMEOUT: u32 = 64;
pub const BEV_EVENT_CONNECTED: u32 = 128;
pub const EVBUFFER_READ: u32 = 1;
pub const EVBUFFER_WRITE: u32 = 2;
pub const EVBUFFER_EOF: u32 = 16;
pub const EVBUFFER_ERROR: u32 = 32;
pub const EVBUFFER_TIMEOUT: u32 = 64;
pub const EVTHREAD_WRITE: u32 = 4;
pub const EVTHREAD_READ: u32 = 8;
pub const EVTHREAD_TRY: u32 = 16;
pub const EVTHREAD_LOCK_API_VERSION: u32 = 1;
pub const EVTHREAD_LOCKTYPE_RECURSIVE: u32 = 1;
pub const EVTHREAD_LOCKTYPE_READWRITE: u32 = 2;
pub const EVTHREAD_CONDITION_API_VERSION: u32 = 1;
pub const EVTHREAD_USE_PTHREADS_IMPLEMENTED: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = u32;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
pub const MSG_OOB: _bindgen_ty_1 = 1;
pub const MSG_PEEK: _bindgen_ty_1 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_1 = 4;
pub const MSG_CTRUNC: _bindgen_ty_1 = 8;
pub const MSG_PROXY: _bindgen_ty_1 = 16;
pub const MSG_TRUNC: _bindgen_ty_1 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_1 = 64;
pub const MSG_EOR: _bindgen_ty_1 = 128;
pub const MSG_WAITALL: _bindgen_ty_1 = 256;
pub const MSG_FIN: _bindgen_ty_1 = 512;
pub const MSG_SYN: _bindgen_ty_1 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_1 = 2048;
pub const MSG_RST: _bindgen_ty_1 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_1 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_1 = 16384;
pub const MSG_MORE: _bindgen_ty_1 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_1 = 65536;
pub const MSG_BATCH: _bindgen_ty_1 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_1 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_1 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_1 = 1073741824;
pub type _bindgen_ty_1 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: size_t,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: size_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: size_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).__cmsg_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: _bindgen_ty_3 = 0;
pub const SHUT_WR: _bindgen_ty_3 = 1;
pub const SHUT_RDWR: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = u32;
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
pub const IPPROTO_IP: _bindgen_ty_4 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_4 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_4 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_4 = 4;
pub const IPPROTO_TCP: _bindgen_ty_4 = 6;
pub const IPPROTO_EGP: _bindgen_ty_4 = 8;
pub const IPPROTO_PUP: _bindgen_ty_4 = 12;
pub const IPPROTO_UDP: _bindgen_ty_4 = 17;
pub const IPPROTO_IDP: _bindgen_ty_4 = 22;
pub const IPPROTO_TP: _bindgen_ty_4 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_4 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_4 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_4 = 46;
pub const IPPROTO_GRE: _bindgen_ty_4 = 47;
pub const IPPROTO_ESP: _bindgen_ty_4 = 50;
pub const IPPROTO_AH: _bindgen_ty_4 = 51;
pub const IPPROTO_MTP: _bindgen_ty_4 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_4 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_4 = 98;
pub const IPPROTO_PIM: _bindgen_ty_4 = 103;
pub const IPPROTO_COMP: _bindgen_ty_4 = 108;
pub const IPPROTO_SCTP: _bindgen_ty_4 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_4 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_4 = 137;
pub const IPPROTO_RAW: _bindgen_ty_4 = 255;
pub const IPPROTO_MAX: _bindgen_ty_4 = 256;
pub type _bindgen_ty_4 = u32;
pub const IPPROTO_HOPOPTS: _bindgen_ty_5 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_5 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_5 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_5 = 58;
pub const IPPROTO_NONE: _bindgen_ty_5 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_5 = 60;
pub const IPPROTO_MH: _bindgen_ty_5 = 135;
pub type _bindgen_ty_5 = u32;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_6 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_6 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_6 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_6 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_6 = 15;
pub const IPPORT_FTP: _bindgen_ty_6 = 21;
pub const IPPORT_TELNET: _bindgen_ty_6 = 23;
pub const IPPORT_SMTP: _bindgen_ty_6 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_6 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_6 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_6 = 43;
pub const IPPORT_MTP: _bindgen_ty_6 = 57;
pub const IPPORT_TFTP: _bindgen_ty_6 = 69;
pub const IPPORT_RJE: _bindgen_ty_6 = 77;
pub const IPPORT_FINGER: _bindgen_ty_6 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_6 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_6 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_6 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_6 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_6 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_6 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_6 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_6 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_6 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_6 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_6 = 5000;
pub type _bindgen_ty_6 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_source as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_fmode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_numsrc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_slist as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_fmode as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_numsrc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_slist as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    assert_eq!(
        ::std::mem::size_of::<rpcent>(),
        24usize,
        concat!("Size of: ", stringify!(rpcent))
    );
    assert_eq!(
        ::std::mem::align_of::<rpcent>(),
        8usize,
        concat!("Alignment of ", stringify!(rpcent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_number as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_number)
        )
    );
}
extern "C" {
    pub fn setrpcent(__stayopen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn getrpcbyname(__name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(__number: ::std::os::raw::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut rpcent,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut rpcent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrpcbynumber_r(
        __number: ::std::os::raw::c_int,
        __result_buf: *mut rpcent,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut rpcent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrpcent_r(
        __result_buf: *mut rpcent,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut rpcent,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_addrtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_net as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_net)
        )
    );
}
extern "C" {
    pub fn __h_errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn herror(__str: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(__err_num: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addrtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addr_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
extern "C" {
    pub fn sethostent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr(
        __addr: *const ::std::os::raw::c_void,
        __len: __socklen_t,
        __type: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(__name: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname2(
        __name: *const ::std::os::raw::c_char,
        __af: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostent_r(
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyaddr_r(
        __addr: *const ::std::os::raw::c_void,
        __len: __socklen_t,
        __type: ::std::os::raw::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname2_r(
        __name: *const ::std::os::raw::c_char,
        __af: ::std::os::raw::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setnetent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getnetbyaddr(__net: u32, __type: ::std::os::raw::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(__name: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent_r(
        __result_buf: *mut netent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut netent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyaddr_r(
        __net: u32,
        __type: ::std::os::raw::c_int,
        __result_buf: *mut netent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut netent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut netent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut netent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_port as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_proto as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_proto)
        )
    );
}
extern "C" {
    pub fn setservent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn getservbyname(
        __name: *const ::std::os::raw::c_char,
        __proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        __port: ::std::os::raw::c_int,
        __proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent_r(
        __result_buf: *mut servent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyname_r(
        __name: *const ::std::os::raw::c_char,
        __proto: *const ::std::os::raw::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyport_r(
        __port: ::std::os::raw::c_int,
        __proto: *const ::std::os::raw::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_proto as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_proto)
        )
    );
}
extern "C" {
    pub fn setprotoent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getprotobyname(__name: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(__proto: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent_r(
        __result_buf: *mut protoent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut protoent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprotobyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut protoent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut protoent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprotobynumber_r(
        __proto: ::std::os::raw::c_int,
        __result_buf: *mut protoent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
        __result: *mut *mut protoent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setnetgrent(__netgroup: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn getnetgrent(
        __hostp: *mut *mut ::std::os::raw::c_char,
        __userp: *mut *mut ::std::os::raw::c_char,
        __domainp: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn innetgr(
        __netgroup: *const ::std::os::raw::c_char,
        __host: *const ::std::os::raw::c_char,
        __user: *const ::std::os::raw::c_char,
        __domain: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetgrent_r(
        __hostp: *mut *mut ::std::os::raw::c_char,
        __userp: *mut *mut ::std::os::raw::c_char,
        __domainp: *mut *mut ::std::os::raw::c_char,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_ushort,
        __locuser: *const ::std::os::raw::c_char,
        __remuser: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_ushort,
        __locuser: *const ::std::os::raw::c_char,
        __remuser: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rexec(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __pass: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rexec_af(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __pass: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        __rhost: *const ::std::os::raw::c_char,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok_af(
        __rhost: *const ::std::os::raw::c_char,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(
        __raddr: u32,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_af(
        __raddr: *const ::std::os::raw::c_void,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(__alport: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(
        __alport: *mut ::std::os::raw::c_int,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_socktype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_canonname as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
extern "C" {
    pub fn getaddrinfo(
        __name: *const ::std::os::raw::c_char,
        __service: *const ::std::os::raw::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeaddrinfo(__ai: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(__ecode: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn getnameinfo(
        __sa: *const sockaddr,
        __salen: socklen_t,
        __host: *mut ::std::os::raw::c_char,
        __hostlen: socklen_t,
        __serv: *mut ::std::os::raw::c_char,
        __servlen: socklen_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Structure to hold information about a monotonic timer"]
#[doc = ""]
#[doc = " Use this with evutil_configure_monotonic_time() and"]
#[doc = " evutil_gettime_monotonic()."]
#[doc = ""]
#[doc = " This is an opaque structure; you can allocate one using"]
#[doc = " evutil_monotonic_timer_new()."]
#[doc = ""]
#[doc = " @see evutil_monotonic_timer_new(), evutil_monotonic_timer_free(),"]
#[doc = " evutil_configure_monotonic_time(), evutil_gettime_monotonic()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evutil_monotonic_timer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Format a date string using RFC 1123 format (used in HTTP)."]
    #[doc = " If `tm` is NULL, current system's time will be used."]
    #[doc = " The number of characters written will be returned."]
    #[doc = " One should check if the return value is smaller than `datelen` to check if"]
    #[doc = " the result is truncated or not."]
    pub fn evutil_date_rfc1123(
        date: *mut ::std::os::raw::c_char,
        datelen: size_t,
        tm: *const tm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a new struct evutil_monotonic_timer for use with the"]
    #[doc = " evutil_configure_monotonic_time() and evutil_gettime_monotonic()"]
    #[doc = " functions.  You must configure the timer with"]
    #[doc = " evutil_configure_monotonic_time() before using it."]
    pub fn evutil_monotonic_timer_new() -> *mut evutil_monotonic_timer;
}
extern "C" {
    #[doc = " Free a struct evutil_monotonic_timer that was allocated using"]
    #[doc = " evutil_monotonic_timer_new()."]
    pub fn evutil_monotonic_timer_free(timer: *mut evutil_monotonic_timer);
}
extern "C" {
    #[doc = " Set up a struct evutil_monotonic_timer; flags can include"]
    #[doc = " EV_MONOT_PRECISE and EV_MONOT_FALLBACK."]
    pub fn evutil_configure_monotonic_time(
        timer: *mut evutil_monotonic_timer,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query the current monotonic time from a struct evutil_monotonic_timer"]
    #[doc = " previously configured with evutil_configure_monotonic_time().  Monotonic"]
    #[doc = " time is guaranteed never to run in reverse, but is not necessarily epoch-"]
    #[doc = " based, or relative to any other definite point.  Use it to make reliable"]
    #[doc = " measurements of elapsed time between events even when the system time"]
    #[doc = " may be changed."]
    #[doc = ""]
    #[doc = " It is not safe to use this funtion on the same timer from multiple"]
    #[doc = " threads."]
    pub fn evutil_gettime_monotonic(
        timer: *mut evutil_monotonic_timer,
        tp: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create two new sockets that are connected to each other."]
    #[doc = ""]
    #[doc = "On Unix, this simply calls socketpair().  On Windows, it uses the"]
    #[doc = "loopback network interface on 127.0.0.1, and only"]
    #[doc = "AF_INET,SOCK_STREAM are supported."]
    #[doc = ""]
    #[doc = "(This may fail on some Windows hosts where firewall software has cleverly"]
    #[doc = "decided to keep 127.0.0.1 from talking to itself.)"]
    #[doc = ""]
    #[doc = "Parameters and return values are as for socketpair()"]
    pub fn evutil_socketpair(
        d: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        sv: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations as needed to make a socket nonblocking."]
    #[doc = ""]
    #[doc = "@param sock The socket to make nonblocking"]
    #[doc = "@return 0 on success, -1 on failure"]
    pub fn evutil_make_socket_nonblocking(sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations to make a listener socket reusable."]
    #[doc = ""]
    #[doc = "Specifically, we want to make sure that another program will be able"]
    #[doc = "to bind this address right after we've closed the listener."]
    #[doc = ""]
    #[doc = "This differs from Windows's interpretation of \"reusable\", which"]
    #[doc = "allows multiple listeners to bind the same address at the same time."]
    #[doc = ""]
    #[doc = "@param sock The socket to make reusable"]
    #[doc = "@return 0 on success, -1 on failure"]
    pub fn evutil_make_listen_socket_reuseable(
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations to make a listener port reusable."]
    #[doc = ""]
    #[doc = "Specifically, we want to make sure that multiple programs which also"]
    #[doc = "set the same socket option will be able to bind, listen at the same time."]
    #[doc = ""]
    #[doc = "This is a feature available only to Linux 3.9+"]
    #[doc = ""]
    #[doc = "@param sock The socket to make reusable"]
    #[doc = "@return 0 on success, -1 on failure"]
    pub fn evutil_make_listen_socket_reuseable_port(
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set ipv6 only bind socket option to make listener work only in ipv6 sockets."]
    #[doc = ""]
    #[doc = "According to RFC3493 and most Linux distributions, default value for the"]
    #[doc = "sockets is to work in IPv4-mapped mode. In IPv4-mapped mode, it is not possible"]
    #[doc = "to bind same port from different IPv4 and IPv6 handlers."]
    #[doc = ""]
    #[doc = "@param sock The socket to make in ipv6only working mode"]
    #[doc = "@return 0 on success, -1 on failure"]
    pub fn evutil_make_listen_socket_ipv6only(sock: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations as needed to close a socket upon a"]
    #[doc = "successful execution of one of the exec*() functions."]
    #[doc = ""]
    #[doc = "@param sock The socket to be closed"]
    #[doc = "@return 0 on success, -1 on failure"]
    pub fn evutil_make_socket_closeonexec(sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do the platform-specific call needed to close a socket returned from"]
    #[doc = "socket() or accept()."]
    #[doc = ""]
    #[doc = "@param sock The socket to be closed"]
    #[doc = "@return 0 on success (whether the operation is supported or not),"]
    #[doc = "-1 on failure"]
    pub fn evutil_closesocket(sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations, if possible, to make a tcp listener"]
    #[doc = "  socket defer accept()s until there is data to read."]
    #[doc = ""]
    #[doc = "  Not all platforms support this.  You don't want to do this for every"]
    #[doc = "  listener socket: only the ones that implement a protocol where the"]
    #[doc = "  client transmits before the server needs to respond."]
    #[doc = ""]
    #[doc = "  @param sock The listening socket to to make deferred"]
    #[doc = "  @return 0 on success (whether the operation is supported or not),"]
    #[doc = "       -1 on failure"]
    pub fn evutil_make_tcp_listen_socket_deferred(
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a 64-bit value from a string.  Arguments are as for strtol."]
    pub fn evutil_strtoll(
        s: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> i64;
}
extern "C" {
    #[doc = " Replacement for snprintf to get consistent behavior on platforms for"]
    #[doc = "which the return value of snprintf does not conform to C99."]
    pub fn evutil_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replacement for vsnprintf to get consistent behavior on platforms for"]
    #[doc = "which the return value of snprintf does not conform to C99."]
    pub fn evutil_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replacement for inet_ntop for platforms which lack it."]
    pub fn evutil_inet_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        len: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Replacement for inet_pton for platforms which lack it."]
    pub fn evutil_inet_pton(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse an IPv4 or IPv6 address, with optional port, from a string."]
    #[doc = ""]
    #[doc = "Recognized formats are:"]
    #[doc = "- [IPv6Address]:port"]
    #[doc = "- [IPv6Address]"]
    #[doc = "- IPv6Address"]
    #[doc = "- IPv4Address:port"]
    #[doc = "- IPv4Address"]
    #[doc = ""]
    #[doc = "If no port is specified, the port in the output is set to 0."]
    #[doc = ""]
    #[doc = "@param str The string to parse."]
    #[doc = "@param out A struct sockaddr to hold the result.  This should probably be"]
    #[doc = "a struct sockaddr_storage."]
    #[doc = "@param outlen A pointer to the number of bytes that that 'out' can safely"]
    #[doc = "hold.  Set to the number of bytes used in 'out' on success."]
    #[doc = "@return -1 if the address is not well-formed, if the port is out of range,"]
    #[doc = "or if out is not large enough to hold the result.  Otherwise returns"]
    #[doc = "0 on success."]
    pub fn evutil_parse_sockaddr_port(
        str: *const ::std::os::raw::c_char,
        out: *mut sockaddr,
        outlen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1"]
    #[doc = " preceeds sa2, or greater than 0 if sa1 follows sa2.  If include_port is"]
    #[doc = " true, consider the port as well as the address.  Only implemented for"]
    #[doc = " AF_INET and AF_INET6 addresses. The ordering is not guaranteed to remain"]
    #[doc = " the same between Libevent versions."]
    pub fn evutil_sockaddr_cmp(
        sa1: *const sockaddr,
        sa2: *const sockaddr,
        include_port: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " As strcasecmp, but always compares the characters in locale-independent"]
    #[doc = "ASCII.  That's useful if you're handling data in ASCII-based protocols."]
    pub fn evutil_ascii_strcasecmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " As strncasecmp, but always compares the characters in locale-independent"]
    #[doc = "ASCII.  That's useful if you're handling data in ASCII-based protocols."]
    pub fn evutil_ascii_strncasecmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function clones getaddrinfo for systems that don't have it.  For full"]
    #[doc = " details, see RFC 3493, section 6.1."]
    #[doc = ""]
    #[doc = " Limitations:"]
    #[doc = " - When the system has no getaddrinfo, we fall back to gethostbyname_r or"]
    #[doc = "   gethostbyname, with their attendant issues."]
    #[doc = " - The AI_V4MAPPED and AI_ALL flags are not currently implemented."]
    #[doc = ""]
    #[doc = " For a nonblocking variant, see evdns_getaddrinfo."]
    pub fn evutil_getaddrinfo(
        nodename: *const ::std::os::raw::c_char,
        servname: *const ::std::os::raw::c_char,
        hints_in: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo."]
    pub fn evutil_freeaddrinfo(ai: *mut addrinfo);
}
extern "C" {
    pub fn evutil_gai_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Generate n bytes of secure pseudorandom data, and store them in buf."]
    #[doc = ""]
    #[doc = " Current versions of Libevent use an ARC4-based random number generator,"]
    #[doc = " seeded using the platform's entropy source (/dev/urandom on Unix-like"]
    #[doc = " systems; CryptGenRandom on Windows).  This is not actually as secure as it"]
    #[doc = " should be: ARC4 is a pretty lousy cipher, and the current implementation"]
    #[doc = " provides only rudimentary prediction- and backtracking-resistance.  Don't"]
    #[doc = " use this for serious cryptographic applications."]
    pub fn evutil_secure_rng_get_bytes(buf: *mut ::std::os::raw::c_void, n: size_t);
}
extern "C" {
    #[doc = " Seed the secure random number generator if needed, and return 0 on"]
    #[doc = " success or -1 on failure."]
    #[doc = ""]
    #[doc = " It is okay to call this function more than once; it will still return"]
    #[doc = " 0 if the RNG has been successfully seeded and -1 if it can't be"]
    #[doc = " seeded."]
    #[doc = ""]
    #[doc = " Ordinarily you don't need to call this function from your own code;"]
    #[doc = " Libevent will seed the RNG itself the first time it needs good random"]
    #[doc = " numbers.  You only need to call it if (a) you want to double-check"]
    #[doc = " that one of the seeding methods did succeed, or (b) you plan to drop"]
    #[doc = " the capability to seed (by chrooting, or dropping capabilities, or"]
    #[doc = " whatever), and you want to make sure that seeding happens before your"]
    #[doc = " program loses the ability to do it."]
    pub fn evutil_secure_rng_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a filename to use in place of /dev/urandom for seeding the secure"]
    #[doc = " PRNG. Return 0 on success, -1 on failure."]
    #[doc = ""]
    #[doc = " Call this function BEFORE calling any other initialization or RNG"]
    #[doc = " functions."]
    #[doc = ""]
    #[doc = " (This string will _NOT_ be copied internally. Do not free it while any"]
    #[doc = " user of the secure RNG might be running. Don't pass anything other than a"]
    #[doc = " real /dev/...random device file here, or you might lose security.)"]
    #[doc = ""]
    #[doc = " This API is unstable, and might change in a future libevent version."]
    pub fn evutil_secure_rng_set_urandom_device_file(
        fname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seed the random number generator with extra random bytes."]
    #[doc = ""]
    #[doc = "You should almost never need to call this function; it should be"]
    #[doc = "sufficient to invoke evutil_secure_rng_init(), or let Libevent take"]
    #[doc = "care of calling evutil_secure_rng_init() on its own."]
    #[doc = ""]
    #[doc = "If you call this function as a _replacement_ for the regular"]
    #[doc = "entropy sources, then you need to be sure that your input"]
    #[doc = "contains a fairly large amount of strong entropy.  Doing so is"]
    #[doc = "notoriously hard: most people who try get it wrong.  Watch out!"]
    #[doc = ""]
    #[doc = "@param dat a buffer full of a strong source of random numbers"]
    #[doc = "@param datlen the number of bytes to read from datlen"]
    pub fn evutil_secure_rng_add_bytes(dat: *const ::std::os::raw::c_char, datlen: size_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evkeyval {
    pub next: evkeyval__bindgen_ty_1,
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evkeyval__bindgen_ty_1 {
    pub tqe_next: *mut evkeyval,
    pub tqe_prev: *mut *mut evkeyval,
}
#[test]
fn bindgen_test_layout_evkeyval__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<evkeyval__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(evkeyval__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<evkeyval__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(evkeyval__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evkeyval__bindgen_ty_1>())).tqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evkeyval__bindgen_ty_1>())).tqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_evkeyval() {
    assert_eq!(
        ::std::mem::size_of::<evkeyval>(),
        32usize,
        concat!("Size of: ", stringify!(evkeyval))
    );
    assert_eq!(
        ::std::mem::align_of::<evkeyval>(),
        8usize,
        concat!("Alignment of ", stringify!(evkeyval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evkeyval>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evkeyval>())).key as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evkeyval>())).value as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evkeyvalq {
    pub tqh_first: *mut evkeyval,
    pub tqh_last: *mut *mut evkeyval,
}
#[test]
fn bindgen_test_layout_evkeyvalq() {
    assert_eq!(
        ::std::mem::size_of::<evkeyvalq>(),
        16usize,
        concat!("Size of: ", stringify!(evkeyvalq))
    );
    assert_eq!(
        ::std::mem::align_of::<evkeyvalq>(),
        8usize,
        concat!("Alignment of ", stringify!(evkeyvalq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evkeyvalq>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyvalq),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evkeyvalq>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyvalq),
            "::",
            stringify!(tqh_last)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event_callback {
    pub evcb_active_next: event_callback__bindgen_ty_1,
    pub evcb_flags: ::std::os::raw::c_short,
    pub evcb_pri: u8,
    pub evcb_closure: u8,
    pub evcb_cb_union: event_callback__bindgen_ty_2,
    pub evcb_arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_callback__bindgen_ty_1 {
    pub tqe_next: *mut event_callback,
    pub tqe_prev: *mut *mut event_callback,
}
#[test]
fn bindgen_test_layout_event_callback__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<event_callback__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(event_callback__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<event_callback__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(event_callback__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event_callback__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event_callback__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union event_callback__bindgen_ty_2 {
    pub evcb_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_short,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    pub evcb_selfcb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut event_callback, arg2: *mut ::std::os::raw::c_void),
    >,
    pub evcb_evfinalize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut event, arg2: *mut ::std::os::raw::c_void),
    >,
    pub evcb_cbfinalize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut event_callback, arg2: *mut ::std::os::raw::c_void),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_event_callback__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<event_callback__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(event_callback__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<event_callback__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(event_callback__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event_callback__bindgen_ty_2>())).evcb_callback as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_2),
            "::",
            stringify!(evcb_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event_callback__bindgen_ty_2>())).evcb_selfcb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_2),
            "::",
            stringify!(evcb_selfcb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event_callback__bindgen_ty_2>())).evcb_evfinalize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_2),
            "::",
            stringify!(evcb_evfinalize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event_callback__bindgen_ty_2>())).evcb_cbfinalize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_2),
            "::",
            stringify!(evcb_cbfinalize)
        )
    );
}
#[test]
fn bindgen_test_layout_event_callback() {
    assert_eq!(
        ::std::mem::size_of::<event_callback>(),
        40usize,
        concat!("Size of: ", stringify!(event_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<event_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(event_callback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_callback>())).evcb_active_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_active_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_callback>())).evcb_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_callback>())).evcb_pri as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_pri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_callback>())).evcb_closure as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_closure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_callback>())).evcb_cb_union as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_cb_union)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_callback>())).evcb_arg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_arg)
        )
    );
}
#[doc = " Structure to hold information and state for a Libevent dispatch loop."]
#[doc = ""]
#[doc = " The event_base lies at the center of Libevent; every application will"]
#[doc = " have one.  It keeps track of all pending and active events, and"]
#[doc = " notifies your application of the active ones."]
#[doc = ""]
#[doc = " This is an opaque structure; you can allocate one using"]
#[doc = " event_base_new() or event_base_new_with_config()."]
#[doc = ""]
#[doc = " @see event_base_new(), event_base_free(), event_base_loop(),"]
#[doc = "    event_base_new_with_config()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_base {
    _unused: [u8; 0],
}
#[doc = " @struct event"]
#[doc = ""]
#[doc = " Structure to represent a single event."]
#[doc = ""]
#[doc = " An event can have some underlying condition it represents: a socket"]
#[doc = " becoming readable or writeable (or both), or a signal becoming raised."]
#[doc = " (An event that represents no underlying condition is still useful: you"]
#[doc = " can use one to implement a timer, or to communicate between threads.)"]
#[doc = ""]
#[doc = " Generally, you can create events with event_new(), then make them"]
#[doc = " pending with event_add().  As your event_base runs, it will run the"]
#[doc = " callbacks of an events whose conditions are triggered.  When you no"]
#[doc = " longer want the event, free it with event_free()."]
#[doc = ""]
#[doc = " In more depth:"]
#[doc = ""]
#[doc = " An event may be \"pending\" (one whose condition we are watching),"]
#[doc = " \"active\" (one whose condition has triggered and whose callback is about"]
#[doc = " to run), neither, or both.  Events come into existence via"]
#[doc = " event_assign() or event_new(), and are then neither active nor pending."]
#[doc = ""]
#[doc = " To make an event pending, pass it to event_add().  When doing so, you"]
#[doc = " can also set a timeout for the event."]
#[doc = ""]
#[doc = " Events become active during an event_base_loop() call when either their"]
#[doc = " condition has triggered, or when their timeout has elapsed.  You can"]
#[doc = " also activate an event manually using event_active().  The even_base"]
#[doc = " loop will run the callbacks of active events; after it has done so, it"]
#[doc = " marks them as no longer active."]
#[doc = ""]
#[doc = " You can make an event non-pending by passing it to event_del().  This"]
#[doc = " also makes the event non-active."]
#[doc = ""]
#[doc = " Events can be \"persistent\" or \"non-persistent\".  A non-persistent event"]
#[doc = " becomes non-pending as soon as it is triggered: thus, it only runs at"]
#[doc = " most once per call to event_add().  A persistent event remains pending"]
#[doc = " even when it becomes active: you'll need to event_del() it manually in"]
#[doc = " order to make it non-pending.  When a persistent event with a timeout"]
#[doc = " becomes active, its timeout is reset: this means you can use persistent"]
#[doc = " events to implement periodic timeouts."]
#[doc = ""]
#[doc = " This should be treated as an opaque structure; you should never read or"]
#[doc = " write any of its fields directly.  For backward compatibility with old"]
#[doc = " code, it is defined in the event2/event_struct.h header; including this"]
#[doc = " header may make your code incompatible with other versions of Libevent."]
#[doc = ""]
#[doc = " @see event_new(), event_free(), event_assign(), event_get_assignment(),"]
#[doc = "    event_add(), event_del(), event_active(), event_pending(),"]
#[doc = "    event_get_fd(), event_get_base(), event_get_events(),"]
#[doc = "    event_get_callback(), event_get_callback_arg(),"]
#[doc = "    event_priority_set()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event {
    pub ev_evcallback: event_callback,
    pub ev_timeout_pos: event__bindgen_ty_1,
    pub ev_fd: ::std::os::raw::c_int,
    pub ev_base: *mut event_base,
    pub ev_: event__bindgen_ty_2,
    pub ev_events: ::std::os::raw::c_short,
    pub ev_res: ::std::os::raw::c_short,
    pub ev_timeout: timeval,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union event__bindgen_ty_1 {
    pub ev_next_with_common_timeout: event__bindgen_ty_1__bindgen_ty_1,
    pub min_heap_idx: ::std::os::raw::c_int,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_1__bindgen_ty_1 {
    pub tqe_next: *mut event,
    pub tqe_prev: *mut *mut event,
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_1__bindgen_ty_1>())).tqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_1__bindgen_ty_1>())).tqe_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_1>())).ev_next_with_common_timeout as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_1),
            "::",
            stringify!(ev_next_with_common_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_1>())).min_heap_idx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_1),
            "::",
            stringify!(min_heap_idx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union event__bindgen_ty_2 {
    pub ev_io: event__bindgen_ty_2__bindgen_ty_1,
    pub ev_signal: event__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_2__bindgen_ty_1 {
    pub ev_io_next: event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub ev_timeout: timeval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut event,
    pub le_prev: *mut *mut event,
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>())).le_next
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>())).le_prev
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_2__bindgen_ty_1>())).ev_io_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(ev_io_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_2__bindgen_ty_1>())).ev_timeout as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(ev_timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_2__bindgen_ty_2 {
    pub ev_signal_next: event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
    pub ev_ncalls: ::std::os::raw::c_short,
    pub ev_pncalls: *mut ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub le_next: *mut event,
    pub le_prev: *mut *mut event,
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>())).le_next
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>())).le_prev
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_2__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_2__bindgen_ty_2>())).ev_signal_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(ev_signal_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_2__bindgen_ty_2>())).ev_ncalls as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(ev_ncalls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<event__bindgen_ty_2__bindgen_ty_2>())).ev_pncalls as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(ev_pncalls)
        )
    );
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(event__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event__bindgen_ty_2>())).ev_io as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2),
            "::",
            stringify!(ev_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event__bindgen_ty_2>())).ev_signal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2),
            "::",
            stringify!(ev_signal)
        )
    );
}
#[test]
fn bindgen_test_layout_event() {
    assert_eq!(
        ::std::mem::size_of::<event>(),
        128usize,
        concat!("Size of: ", stringify!(event))
    );
    assert_eq!(
        ::std::mem::align_of::<event>(),
        8usize,
        concat!("Alignment of ", stringify!(event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event>())).ev_evcallback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_evcallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event>())).ev_timeout_pos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_timeout_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event>())).ev_fd as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event>())).ev_base as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event>())).ev_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event>())).ev_events as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event>())).ev_res as *const _ as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_res)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event>())).ev_timeout as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_list {
    pub tqh_first: *mut event,
    pub tqh_last: *mut *mut event,
}
#[test]
fn bindgen_test_layout_event_list() {
    assert_eq!(
        ::std::mem::size_of::<event_list>(),
        16usize,
        concat!("Size of: ", stringify!(event_list))
    );
    assert_eq!(
        ::std::mem::align_of::<event_list>(),
        8usize,
        concat!("Alignment of ", stringify!(event_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_dlist {
    pub lh_first: *mut event,
}
#[test]
fn bindgen_test_layout_event_dlist() {
    assert_eq!(
        ::std::mem::size_of::<event_dlist>(),
        8usize,
        concat!("Size of: ", stringify!(event_dlist))
    );
    assert_eq!(
        ::std::mem::align_of::<event_dlist>(),
        8usize,
        concat!("Alignment of ", stringify!(event_dlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_dlist>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_dlist),
            "::",
            stringify!(lh_first)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " Configuration for an event_base."]
#[doc = ""]
#[doc = " There are many options that can be used to alter the behavior and"]
#[doc = " implementation of an event_base.  To avoid having to pass them all in a"]
#[doc = " complex many-argument constructor, we provide an abstract data type"]
#[doc = " where you set up configuration information before passing it to"]
#[doc = " event_base_new_with_config()."]
#[doc = ""]
#[doc = " @see event_config_new(), event_config_free(), event_base_new_with_config(),"]
#[doc = "   event_config_avoid_method(), event_config_require_features(),"]
#[doc = "   event_config_set_flag(), event_config_set_num_cpus_hint()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_config {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Enable some relatively expensive debugging checks in Libevent that"]
    #[doc = " would normally be turned off.  Generally, these checks cause code that"]
    #[doc = " would otherwise crash mysteriously to fail earlier with an assertion"]
    #[doc = " failure.  Note that this method MUST be called before any events or"]
    #[doc = " event_bases have been created."]
    #[doc = ""]
    #[doc = " Debug mode can currently catch the following errors:"]
    #[doc = "    An event is re-assigned while it is added"]
    #[doc = "    Any function is called on a non-assigned event"]
    #[doc = ""]
    #[doc = " Note that debugging mode uses memory to track every event that has been"]
    #[doc = " initialized (via event_assign, event_set, or event_new) but not yet"]
    #[doc = " released (via event_free or event_debug_unassign).  If you want to use"]
    #[doc = " debug mode, and you find yourself running out of memory, you will need"]
    #[doc = " to use event_debug_unassign to explicitly stop tracking events that"]
    #[doc = " are no longer considered set-up."]
    #[doc = ""]
    #[doc = " @see event_debug_unassign()"]
    pub fn event_enable_debug_mode();
}
extern "C" {
    #[doc = " When debugging mode is enabled, informs Libevent that an event should no"]
    #[doc = " longer be considered as assigned. When debugging mode is not enabled, does"]
    #[doc = " nothing."]
    #[doc = ""]
    #[doc = " This function must only be called on a non-added event."]
    #[doc = ""]
    #[doc = " @see event_enable_debug_mode()"]
    pub fn event_debug_unassign(arg1: *mut event);
}
extern "C" {
    #[doc = " Create and return a new event_base to use with the rest of Libevent."]
    #[doc = ""]
    #[doc = " @return a new event_base on success, or NULL on failure."]
    #[doc = ""]
    #[doc = " @see event_base_free(), event_base_new_with_config()"]
    pub fn event_base_new() -> *mut event_base;
}
extern "C" {
    #[doc = "Reinitialize the event base after a fork"]
    #[doc = ""]
    #[doc = "Some event mechanisms do not survive across fork.   The event base needs"]
    #[doc = "to be reinitialized with the event_reinit() function."]
    #[doc = ""]
    #[doc = "@param base the event base that needs to be re-initialized"]
    #[doc = "@return 0 if successful, or -1 if some events could not be re-added."]
    #[doc = "@see event_base_new()"]
    pub fn event_reinit(base: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Event dispatching loop"]
    #[doc = ""]
    #[doc = "This loop will run the event base until either there are no more pending or"]
    #[doc = "active, or until something calls event_base_loopbreak() or"]
    #[doc = "event_base_loopexit()."]
    #[doc = ""]
    #[doc = "@param base the event_base structure returned by event_base_new() or"]
    #[doc = "event_base_new_with_config()"]
    #[doc = "@return 0 if successful, -1 if an error occurred, or 1 if we exited because"]
    #[doc = "no events were pending or active."]
    #[doc = "@see event_base_loop()"]
    pub fn event_base_dispatch(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the kernel event notification mechanism used by Libevent."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_base_new()"]
    #[doc = "@return a string identifying the kernel event mechanism (kqueue, epoll, etc.)"]
    pub fn event_base_get_method(arg1: *const event_base) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Gets all event notification mechanisms supported by Libevent."]
    #[doc = ""]
    #[doc = "This functions returns the event mechanism in order preferred by"]
    #[doc = "Libevent.  Note that this list will include all backends that"]
    #[doc = "Libevent has compiled-in support for, and will not necessarily check"]
    #[doc = "your OS to see whether it has the required resources."]
    #[doc = ""]
    #[doc = "@return an array with pointers to the names of support methods."]
    #[doc = "The end of the array is indicated by a NULL pointer.  If an"]
    #[doc = "error is encountered NULL is returned."]
    pub fn event_get_supported_methods() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Query the current monotonic time from a the timer for a struct"]
    #[doc = " event_base."]
    pub fn event_gettime_monotonic(
        base: *mut event_base,
        tp: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Gets the number of events in event_base, as specified in the flags."]
    #[doc = ""]
    #[doc = "Since event base has some internal events added to make some of its"]
    #[doc = "functionalities work, EVENT_BASE_COUNT_ADDED may return more than the"]
    #[doc = "number of events you added using event_add()."]
    #[doc = ""]
    #[doc = "If you pass EVENT_BASE_COUNT_ACTIVE and EVENT_BASE_COUNT_ADDED together, an"]
    #[doc = "active event will be counted twice. However, this might not be the case in"]
    #[doc = "future libevent versions.  The return value is an indication of the work"]
    #[doc = "load, but the user shouldn't rely on the exact value as this may change in"]
    #[doc = "the future."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_base_new()"]
    #[doc = "@param flags a bitwise combination of the kinds of events to aggregate"]
    #[doc = "counts for"]
    #[doc = "@return the number of events specified in the flags"]
    pub fn event_base_get_num_events(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the maximum number of events in a given event_base as specified in the"]
    #[doc = "flags."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_base_new()"]
    #[doc = "@param flags a bitwise combination of the kinds of events to aggregate"]
    #[doc = "counts for"]
    #[doc = "@param clear option used to reset the maximum count."]
    #[doc = "@return the number of events specified in the flags"]
    pub fn event_base_get_max_events(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Allocates a new event configuration object."]
    #[doc = ""]
    #[doc = "The event configuration object can be used to change the behavior of"]
    #[doc = "an event base."]
    #[doc = ""]
    #[doc = "@return an event_config object that can be used to store configuration, or"]
    #[doc = "NULL if an error is encountered."]
    #[doc = "@see event_base_new_with_config(), event_config_free(), event_config"]
    pub fn event_config_new() -> *mut event_config;
}
extern "C" {
    #[doc = "Deallocates all memory associated with an event configuration object"]
    #[doc = ""]
    #[doc = "@param cfg the event configuration object to be freed."]
    pub fn event_config_free(cfg: *mut event_config);
}
extern "C" {
    #[doc = "Enters an event method that should be avoided into the configuration."]
    #[doc = ""]
    #[doc = "This can be used to avoid event mechanisms that do not support certain"]
    #[doc = "file descriptor types, or for debugging to avoid certain event"]
    #[doc = "mechanisms.  An application can make use of multiple event bases to"]
    #[doc = "accommodate incompatible file descriptor types."]
    #[doc = ""]
    #[doc = "@param cfg the event configuration object"]
    #[doc = "@param method the name of the event method to avoid"]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn event_config_avoid_method(
        cfg: *mut event_config,
        method: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Require an event method that allows edge-triggered events with EV_ET."]
pub const event_method_feature_EV_FEATURE_ET: event_method_feature = 1;
#[doc = " Require an event method where having one event triggered among"]
#[doc = " many is [approximately] an O(1) operation. This excludes (for"]
#[doc = " example) select and poll, which are approximately O(N) for N"]
#[doc = " equal to the total number of possible events."]
pub const event_method_feature_EV_FEATURE_O1: event_method_feature = 2;
#[doc = " Require an event method that allows file descriptors as well as"]
#[doc = " sockets."]
pub const event_method_feature_EV_FEATURE_FDS: event_method_feature = 4;
#[doc = " Require an event method that allows you to use EV_CLOSED to detect"]
#[doc = " connection close without the necessity of reading all the pending data."]
#[doc = ""]
#[doc = " Methods that do support EV_CLOSED may not be able to provide support on"]
#[doc = " all kernel versions."]
pub const event_method_feature_EV_FEATURE_EARLY_CLOSE: event_method_feature = 8;
#[doc = "A flag used to describe which features an event_base (must) provide."]
#[doc = ""]
#[doc = "Because of OS limitations, not every Libevent backend supports every"]
#[doc = "possible feature.  You can use this type with"]
#[doc = "event_config_require_features() to tell Libevent to only proceed if your"]
#[doc = "event_base implements a given feature, and you can receive this type from"]
#[doc = "event_base_get_features() to see which features are available."]
pub type event_method_feature = u32;
#[doc = " Do not allocate a lock for the event base, even if we have"]
#[doc = "locking set up."]
#[doc = ""]
#[doc = "Setting this option will make it unsafe and nonfunctional to call"]
#[doc = "functions on the base concurrently from multiple threads."]
pub const event_base_config_flag_EVENT_BASE_FLAG_NOLOCK: event_base_config_flag = 1;
#[doc = " Do not check the EVENT_* environment variables when configuring"]
#[doc = "an event_base"]
pub const event_base_config_flag_EVENT_BASE_FLAG_IGNORE_ENV: event_base_config_flag = 2;
#[doc = " Windows only: enable the IOCP dispatcher at startup"]
#[doc = ""]
#[doc = "If this flag is set then bufferevent_socket_new() and"]
#[doc = "evconn_listener_new() will use IOCP-backed implementations"]
#[doc = "instead of the usual select-based one on Windows."]
pub const event_base_config_flag_EVENT_BASE_FLAG_STARTUP_IOCP: event_base_config_flag = 4;
#[doc = " Instead of checking the current time every time the event loop is"]
#[doc = "ready to run timeout callbacks, check after each timeout callback."]
pub const event_base_config_flag_EVENT_BASE_FLAG_NO_CACHE_TIME: event_base_config_flag = 8;
#[doc = " If we are using the epoll backend, this flag says that it is"]
#[doc = "safe to use Libevent's internal change-list code to batch up"]
#[doc = "adds and deletes in order to try to do as few syscalls as"]
#[doc = "possible.  Setting this flag can make your code run faster, but"]
#[doc = "it may trigger a Linux bug: it is not safe to use this flag"]
#[doc = "if you have any fds cloned by dup() or its variants.  Doing so"]
#[doc = "will produce strange and hard-to-diagnose bugs."]
#[doc = ""]
#[doc = "This flag can also be activated by setting the"]
#[doc = "EVENT_EPOLL_USE_CHANGELIST environment variable."]
#[doc = ""]
#[doc = "This flag has no effect if you wind up using a backend other than"]
#[doc = "epoll."]
pub const event_base_config_flag_EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST: event_base_config_flag = 16;
#[doc = " Ordinarily, Libevent implements its time and timeout code using"]
#[doc = "the fastest monotonic timer that we have.  If this flag is set,"]
#[doc = "however, we use less efficient more precise timer, assuming one is"]
#[doc = "present."]
pub const event_base_config_flag_EVENT_BASE_FLAG_PRECISE_TIMER: event_base_config_flag = 32;
#[doc = "A flag passed to event_config_set_flag()."]
#[doc = ""]
#[doc = "These flags change the behavior of an allocated event_base."]
#[doc = ""]
#[doc = "@see event_config_set_flag(), event_base_new_with_config(),"]
#[doc = "event_method_feature"]
pub type event_base_config_flag = u32;
extern "C" {
    #[doc = "Return a bitmask of the features implemented by an event base.  This"]
    #[doc = "will be a bitwise OR of one or more of the values of"]
    #[doc = "event_method_feature"]
    #[doc = ""]
    #[doc = "@see event_method_feature"]
    pub fn event_base_get_features(base: *const event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Enters a required event method feature that the application demands."]
    #[doc = ""]
    #[doc = "Note that not every feature or combination of features is supported"]
    #[doc = "on every platform.  Code that requests features should be prepared"]
    #[doc = "to handle the case where event_base_new_with_config() returns NULL, as in:"]
    #[doc = "<pre>"]
    #[doc = "event_config_require_features(cfg, EV_FEATURE_ET);"]
    #[doc = "base = event_base_new_with_config(cfg);"]
    #[doc = "if (base == NULL) {"]
    #[doc = "event_config_require_features(cfg, 0);"]
    #[doc = "base = event_base_new_with_config(cfg);"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "@param cfg the event configuration object"]
    #[doc = "@param feature a bitfield of one or more event_method_feature values."]
    #[doc = "Replaces values from previous calls to this function."]
    #[doc = "@return 0 on success, -1 on failure."]
    #[doc = "@see event_method_feature, event_base_new_with_config()"]
    pub fn event_config_require_features(
        cfg: *mut event_config,
        feature: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets one or more flags to configure what parts of the eventual event_base"]
    #[doc = " will be initialized, and how they'll work."]
    #[doc = ""]
    #[doc = " @see event_base_config_flags, event_base_new_with_config()"]
    pub fn event_config_set_flag(
        cfg: *mut event_config,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Records a hint for the number of CPUs in the system. This is used for"]
    #[doc = " tuning thread pools, etc, for optimal performance.  In Libevent 2.0,"]
    #[doc = " it is only on Windows, and only when IOCP is in use."]
    #[doc = ""]
    #[doc = " @param cfg the event configuration object"]
    #[doc = " @param cpus the number of cpus"]
    #[doc = " @return 0 on success, -1 on failure."]
    pub fn event_config_set_num_cpus_hint(
        cfg: *mut event_config,
        cpus: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Record an interval and/or a number of callbacks after which the event base"]
    #[doc = " should check for new events.  By default, the event base will run as many"]
    #[doc = " events are as activated at the highest activated priority before checking"]
    #[doc = " for new events.  If you configure it by setting max_interval, it will check"]
    #[doc = " the time after each callback, and not allow more than max_interval to"]
    #[doc = " elapse before checking for new events.  If you configure it by setting"]
    #[doc = " max_callbacks to a value >= 0, it will run no more than max_callbacks"]
    #[doc = " callbacks before checking for new events."]
    #[doc = ""]
    #[doc = " This option can decrease the latency of high-priority events, and"]
    #[doc = " avoid priority inversions where multiple low-priority events keep us from"]
    #[doc = " polling for high-priority events, but at the expense of slightly decreasing"]
    #[doc = " the throughput.  Use it with caution!"]
    #[doc = ""]
    #[doc = " @param cfg The event_base configuration object."]
    #[doc = " @param max_interval An interval after which Libevent should stop running"]
    #[doc = "     callbacks and check for more events, or NULL if there should be"]
    #[doc = "     no such interval."]
    #[doc = " @param max_callbacks A number of callbacks after which Libevent should"]
    #[doc = "     stop running callbacks and check for more events, or -1 if there"]
    #[doc = "     should be no such limit."]
    #[doc = " @param min_priority A priority below which max_interval and max_callbacks"]
    #[doc = "     should not be enforced.  If this is set to 0, they are enforced"]
    #[doc = "     for events of every priority; if it's set to 1, they're enforced"]
    #[doc = "     for events of priority 1 and above, and so on."]
    #[doc = " @return 0 on success, -1 on failure."]
    pub fn event_config_set_max_dispatch_interval(
        cfg: *mut event_config,
        max_interval: *const timeval,
        max_callbacks: ::std::os::raw::c_int,
        min_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Initialize the event API."]
    #[doc = ""]
    #[doc = "Use event_base_new_with_config() to initialize a new event base, taking"]
    #[doc = "the specified configuration under consideration.  The configuration object"]
    #[doc = "can currently be used to avoid certain event notification mechanisms."]
    #[doc = ""]
    #[doc = "@param cfg the event configuration object"]
    #[doc = "@return an initialized event_base that can be used to registering events,"]
    #[doc = "or NULL if no event base can be created with the requested event_config."]
    #[doc = "@see event_base_new(), event_base_free(), event_init(), event_assign()"]
    pub fn event_base_new_with_config(arg1: *const event_config) -> *mut event_base;
}
extern "C" {
    #[doc = "Deallocate all memory associated with an event_base, and free the base."]
    #[doc = ""]
    #[doc = "Note that this function will not close any fds or free any memory passed"]
    #[doc = "to event_new as the argument to callback."]
    #[doc = ""]
    #[doc = "If there are any pending finalizer callbacks, this function will invoke"]
    #[doc = "them."]
    #[doc = ""]
    #[doc = "@param eb an event_base to be freed"]
    pub fn event_base_free(arg1: *mut event_base);
}
extern "C" {
    #[doc = "As event_base_free, but do not run finalizers."]
    pub fn event_base_free_nofinalize(arg1: *mut event_base);
}
#[doc = "A callback function used to intercept Libevent's log messages."]
#[doc = ""]
#[doc = "@see event_set_log_callback"]
pub type event_log_cb = ::std::option::Option<
    unsafe extern "C" fn(severity: ::std::os::raw::c_int, msg: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = "Redirect Libevent's log messages."]
    #[doc = ""]
    #[doc = "@param cb a function taking two arguments: an integer severity between"]
    #[doc = "EVENT_LOG_DEBUG and EVENT_LOG_ERR, and a string.  If cb is NULL,"]
    #[doc = "then the default log is used."]
    #[doc = ""]
    #[doc = "NOTE: The function you provide *must not* call any other libevent"]
    #[doc = "functionality.  Doing so can produce undefined behavior."]
    pub fn event_set_log_callback(cb: event_log_cb);
}
#[doc = "A function to be called if Libevent encounters a fatal internal error."]
#[doc = ""]
#[doc = "@see event_set_fatal_callback"]
pub type event_fatal_cb = ::std::option::Option<unsafe extern "C" fn(err: ::std::os::raw::c_int)>;
extern "C" {
    #[doc = "Override Libevent's behavior in the event of a fatal internal error."]
    #[doc = ""]
    #[doc = "By default, Libevent will call exit(1) if a programming error makes it"]
    #[doc = "impossible to continue correct operation.  This function allows you to supply"]
    #[doc = "another callback instead.  Note that if the function is ever invoked,"]
    #[doc = "something is wrong with your program, or with Libevent: any subsequent calls"]
    #[doc = "to Libevent may result in undefined behavior."]
    #[doc = ""]
    #[doc = "Libevent will (almost) always log an EVENT_LOG_ERR message before calling"]
    #[doc = "this function; look at the last log message to see why Libevent has died."]
    pub fn event_set_fatal_callback(cb: event_fatal_cb);
}
extern "C" {
    #[doc = "Turn on debugging logs and have them sent to the default log handler."]
    #[doc = ""]
    #[doc = "This is a global setting; if you are going to call it, you must call this"]
    #[doc = "before any calls that create an event-base.  You must call it before any"]
    #[doc = "multithreaded use of Libevent."]
    #[doc = ""]
    #[doc = "Debug logs are verbose."]
    #[doc = ""]
    #[doc = "@param which Controls which debug messages are turned on.  This option is"]
    #[doc = "unused for now; for forward compatibility, you must pass in the constant"]
    #[doc = "\"EVENT_DBG_ALL\" to turn debugging logs on, or \"EVENT_DBG_NONE\" to turn"]
    #[doc = "debugging logs off."]
    pub fn event_enable_debug_logging(which: u32);
}
extern "C" {
    #[doc = "Associate a different event base with an event."]
    #[doc = ""]
    #[doc = "The event to be associated must not be currently active or pending."]
    #[doc = ""]
    #[doc = "@param eb the event base"]
    #[doc = "@param ev the event"]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn event_base_set(arg1: *mut event_base, arg2: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Wait for events to become active, and run their callbacks."]
    #[doc = ""]
    #[doc = "This is a more flexible version of event_base_dispatch()."]
    #[doc = ""]
    #[doc = "By default, this loop will run the event base until either there are no more"]
    #[doc = "pending or active events, or until something calls event_base_loopbreak() or"]
    #[doc = "event_base_loopexit().  You can override this behavior with the 'flags'"]
    #[doc = "argument."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_base_new() or"]
    #[doc = "event_base_new_with_config()"]
    #[doc = "@param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK"]
    #[doc = "@return 0 if successful, -1 if an error occurred, or 1 if we exited because"]
    #[doc = "no events were pending or active."]
    #[doc = "@see event_base_loopexit(), event_base_dispatch(), EVLOOP_ONCE,"]
    #[doc = "EVLOOP_NONBLOCK"]
    pub fn event_base_loop(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Exit the event loop after the specified time"]
    #[doc = ""]
    #[doc = "The next event_base_loop() iteration after the given timer expires will"]
    #[doc = "complete normally (handling all queued events) then exit without"]
    #[doc = "blocking for events again."]
    #[doc = ""]
    #[doc = "Subsequent invocations of event_base_loop() will proceed normally."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_init()"]
    #[doc = "@param tv the amount of time after which the loop should terminate,"]
    #[doc = "or NULL to exit after running all currently active events."]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see event_base_loopbreak()"]
    pub fn event_base_loopexit(
        arg1: *mut event_base,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Abort the active event_base_loop() immediately."]
    #[doc = ""]
    #[doc = "event_base_loop() will abort the loop after the next event is completed;"]
    #[doc = "event_base_loopbreak() is typically invoked from this event's callback."]
    #[doc = "This behavior is analogous to the \"break;\" statement."]
    #[doc = ""]
    #[doc = "Subsequent invocations of event_base_loop() will proceed normally."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_init()"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see event_base_loopexit()"]
    pub fn event_base_loopbreak(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Tell the active event_base_loop() to scan for new events immediately."]
    #[doc = ""]
    #[doc = "Calling this function makes the currently active event_base_loop()"]
    #[doc = "start the loop over again (scanning for new events) after the current"]
    #[doc = "event callback finishes.  If the event loop is not running, this"]
    #[doc = "function has no effect."]
    #[doc = ""]
    #[doc = "event_base_loopbreak() is typically invoked from this event's callback."]
    #[doc = "This behavior is analogous to the \"continue;\" statement."]
    #[doc = ""]
    #[doc = "Subsequent invocations of event loop will proceed normally."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_init()"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see event_base_loopbreak()"]
    pub fn event_base_loopcontinue(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Checks if the event loop was told to exit by event_base_loopexit()."]
    #[doc = ""]
    #[doc = "This function will return true for an event_base at every point after"]
    #[doc = "event_loopexit() is called, until the event loop is next entered."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_init()"]
    #[doc = "@return true if event_base_loopexit() was called on this event base,"]
    #[doc = "or 0 otherwise"]
    #[doc = "@see event_base_loopexit()"]
    #[doc = "@see event_base_got_break()"]
    pub fn event_base_got_exit(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Checks if the event loop was told to abort immediately by event_base_loopbreak()."]
    #[doc = ""]
    #[doc = "This function will return true for an event_base at every point after"]
    #[doc = "event_base_loopbreak() is called, until the event loop is next entered."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_init()"]
    #[doc = "@return true if event_base_loopbreak() was called on this event base,"]
    #[doc = "or 0 otherwise"]
    #[doc = "@see event_base_loopbreak()"]
    #[doc = "@see event_base_got_exit()"]
    pub fn event_base_got_break(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
#[doc = "A callback function for an event."]
#[doc = ""]
#[doc = "It receives three arguments:"]
#[doc = ""]
#[doc = "@param fd An fd or signal"]
#[doc = "@param events One or more EV_* flags"]
#[doc = "@param arg A user-supplied argument."]
#[doc = ""]
#[doc = "@see event_new()"]
pub type event_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_short,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Return a value used to specify that the event itself must be used as the callback argument."]
    #[doc = ""]
    #[doc = "The function event_new() takes a callback argument which is passed"]
    #[doc = "to the event's callback function. To specify that the argument to be"]
    #[doc = "passed to the callback function is the event that event_new() returns,"]
    #[doc = "pass in the return value of event_self_cbarg() as the callback argument"]
    #[doc = "for event_new()."]
    #[doc = ""]
    #[doc = "For example:"]
    #[doc = "<pre>"]
    #[doc = "struct event *ev = event_new(base, sock, events, callback, %event_self_cbarg());"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "For consistency with event_new(), it is possible to pass the return value"]
    #[doc = "of this function as the callback argument for event_assign() &ndash; this"]
    #[doc = "achieves the same result as passing the event in directly."]
    #[doc = ""]
    #[doc = "@return a value to be passed as the callback argument to event_new() or"]
    #[doc = "event_assign()."]
    #[doc = "@see event_new(), event_assign()"]
    pub fn event_self_cbarg() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Allocate and assign a new event structure, ready to be added."]
    #[doc = ""]
    #[doc = "The function event_new() returns a new event that can be used in"]
    #[doc = "future calls to event_add() and event_del().  The fd and events"]
    #[doc = "arguments determine which conditions will trigger the event; the"]
    #[doc = "callback and callback_arg arguments tell Libevent what to do when the"]
    #[doc = "event becomes active."]
    #[doc = ""]
    #[doc = "If events contains one of EV_READ, EV_WRITE, or EV_READ|EV_WRITE, then"]
    #[doc = "fd is a file descriptor or socket that should get monitored for"]
    #[doc = "readiness to read, readiness to write, or readiness for either operation"]
    #[doc = "(respectively).  If events contains EV_SIGNAL, then fd is a signal"]
    #[doc = "number to wait for.  If events contains none of those flags, then the"]
    #[doc = "event can be triggered only by a timeout or by manual activation with"]
    #[doc = "event_active(): In this case, fd must be -1."]
    #[doc = ""]
    #[doc = "The EV_PERSIST flag can also be passed in the events argument: it makes"]
    #[doc = "event_add() persistent until event_del() is called."]
    #[doc = ""]
    #[doc = "The EV_ET flag is compatible with EV_READ and EV_WRITE, and supported"]
    #[doc = "only by certain backends.  It tells Libevent to use edge-triggered"]
    #[doc = "events."]
    #[doc = ""]
    #[doc = "The EV_TIMEOUT flag has no effect here."]
    #[doc = ""]
    #[doc = "It is okay to have multiple events all listening on the same fds; but"]
    #[doc = "they must either all be edge-triggered, or all not be edge triggered."]
    #[doc = ""]
    #[doc = "When the event becomes active, the event loop will run the provided"]
    #[doc = "callback function, with three arguments.  The first will be the provided"]
    #[doc = "fd value.  The second will be a bitfield of the events that triggered:"]
    #[doc = "EV_READ, EV_WRITE, or EV_SIGNAL.  Here the EV_TIMEOUT flag indicates"]
    #[doc = "that a timeout occurred, and EV_ET indicates that an edge-triggered"]
    #[doc = "event occurred.  The third event will be the callback_arg pointer that"]
    #[doc = "you provide."]
    #[doc = ""]
    #[doc = "@param base the event base to which the event should be attached."]
    #[doc = "@param fd the file descriptor or signal to be monitored, or -1."]
    #[doc = "@param events desired events to monitor: bitfield of EV_READ, EV_WRITE,"]
    #[doc = "EV_SIGNAL, EV_PERSIST, EV_ET."]
    #[doc = "@param callback callback function to be invoked when the event occurs"]
    #[doc = "@param callback_arg an argument to be passed to the callback function"]
    #[doc = ""]
    #[doc = "@return a newly allocated struct event that must later be freed with"]
    #[doc = "event_free() or NULL if an error occurred."]
    #[doc = "@see event_free(), event_add(), event_del(), event_assign()"]
    pub fn event_new(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_short,
        arg4: event_callback_fn,
        arg5: *mut ::std::os::raw::c_void,
    ) -> *mut event;
}
extern "C" {
    #[doc = "Prepare a new, already-allocated event structure to be added."]
    #[doc = ""]
    #[doc = "The function event_assign() prepares the event structure ev to be used"]
    #[doc = "in future calls to event_add() and event_del().  Unlike event_new(), it"]
    #[doc = "doesn't allocate memory itself: it requires that you have already"]
    #[doc = "allocated a struct event, probably on the heap.  Doing this will"]
    #[doc = "typically make your code depend on the size of the event structure, and"]
    #[doc = "thereby create incompatibility with future versions of Libevent."]
    #[doc = ""]
    #[doc = "The easiest way to avoid this problem is just to use event_new() and"]
    #[doc = "event_free() instead."]
    #[doc = ""]
    #[doc = "A slightly harder way to future-proof your code is to use"]
    #[doc = "event_get_struct_event_size() to determine the required size of an event"]
    #[doc = "at runtime."]
    #[doc = ""]
    #[doc = "Note that it is NOT safe to call this function on an event that is"]
    #[doc = "active or pending.  Doing so WILL corrupt internal data structures in"]
    #[doc = "Libevent, and lead to strange, hard-to-diagnose bugs.  You _can_ use"]
    #[doc = "event_assign to change an existing event, but only if it is not active"]
    #[doc = "or pending!"]
    #[doc = ""]
    #[doc = "The arguments for this function, and the behavior of the events that it"]
    #[doc = "makes, are as for event_new()."]
    #[doc = ""]
    #[doc = "@param ev an event struct to be modified"]
    #[doc = "@param base the event base to which ev should be attached."]
    #[doc = "@param fd the file descriptor to be monitored"]
    #[doc = "@param events desired events to monitor; can be EV_READ and/or EV_WRITE"]
    #[doc = "@param callback callback function to be invoked when the event occurs"]
    #[doc = "@param callback_arg an argument to be passed to the callback function"]
    #[doc = ""]
    #[doc = "@return 0 if success, or -1 on invalid arguments."]
    #[doc = ""]
    #[doc = "@see event_new(), event_add(), event_del(), event_base_once(),"]
    #[doc = "event_get_struct_event_size()"]
    pub fn event_assign(
        arg1: *mut event,
        arg2: *mut event_base,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_short,
        arg5: event_callback_fn,
        arg6: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Deallocate a struct event * returned by event_new()."]
    #[doc = ""]
    #[doc = "If the event is pending or active, this function makes it non-pending"]
    #[doc = "and non-active first."]
    pub fn event_free(arg1: *mut event);
}
#[doc = " Callback type for event_finalize and event_free_finalize()."]
pub type event_finalize_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut event, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = "@name Finalization functions"]
    #[doc = ""]
    #[doc = "These functions are used to safely tear down an event in a multithreaded"]
    #[doc = "application.  If you construct your events with EV_FINALIZE to avoid"]
    #[doc = "deadlocks, you will need a way to remove an event in the certainty that"]
    #[doc = "it will definitely not be running its callback when you deallocate it"]
    #[doc = "and its callback argument."]
    #[doc = ""]
    #[doc = "To do this, call one of event_finalize() or event_free_finalize with"]
    #[doc = "0 for its first argument, the event to tear down as its second argument,"]
    #[doc = "and a callback function as its third argument.  The callback will be"]
    #[doc = "invoked as part of the event loop, with the event's priority."]
    #[doc = ""]
    #[doc = "After you call a finalizer function, event_add() and event_active() will"]
    #[doc = "no longer work on the event, and event_del() will produce a no-op. You"]
    #[doc = "must not try to change the event's fields with event_assign() or"]
    #[doc = "event_set() while the finalize callback is in progress.  Once the"]
    #[doc = "callback has been invoked, you should treat the event structure as"]
    #[doc = "containing uninitialized memory."]
    #[doc = ""]
    #[doc = "The event_free_finalize() function frees the event after it's finalized;"]
    #[doc = "event_finalize() does not."]
    #[doc = ""]
    #[doc = "A finalizer callback must not make events pending or active.  It must not"]
    #[doc = "add events, activate events, or attempt to \"resuscitate\" the event being"]
    #[doc = "finalized in any way."]
    #[doc = ""]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn event_finalize(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut event,
        arg3: event_finalize_callback_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn event_free_finalize(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut event,
        arg3: event_finalize_callback_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Schedule a one-time event"]
    #[doc = ""]
    #[doc = "The function event_base_once() is similar to event_new().  However, it"]
    #[doc = "schedules a callback to be called exactly once, and does not require the"]
    #[doc = "caller to prepare an event structure."]
    #[doc = ""]
    #[doc = "Note that in Libevent 2.0 and earlier, if the event is never triggered, the"]
    #[doc = "internal memory used to hold it will never be freed.  In Libevent 2.1,"]
    #[doc = "the internal memory will get freed by event_base_free() if the event"]
    #[doc = "is never triggered.  The 'arg' value, however, will not get freed in either"]
    #[doc = "case--you'll need to free that on your own if you want it to go away."]
    #[doc = ""]
    #[doc = "@param base an event_base"]
    #[doc = "@param fd a file descriptor to monitor, or -1 for no fd."]
    #[doc = "@param events event(s) to monitor; can be any of EV_READ |"]
    #[doc = "EV_WRITE, or EV_TIMEOUT"]
    #[doc = "@param callback callback function to be invoked when the event occurs"]
    #[doc = "@param arg an argument to be passed to the callback function"]
    #[doc = "@param timeout the maximum amount of time to wait for the event. NULL"]
    #[doc = "makes an EV_READ/EV_WRITE event make forever; NULL makes an"]
    #[doc = "EV_TIMEOUT event success immediately."]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    pub fn event_base_once(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_short,
        arg4: event_callback_fn,
        arg5: *mut ::std::os::raw::c_void,
        arg6: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Add an event to the set of pending events."]
    #[doc = ""]
    #[doc = "The function event_add() schedules the execution of the event 'ev' when the"]
    #[doc = "condition specified by event_assign() or event_new() occurs, or when the time"]
    #[doc = "specified in timeout has elapsed.  If a timeout is NULL, no timeout"]
    #[doc = "occurs and the function will only be"]
    #[doc = "called if a matching event occurs.  The event in the"]
    #[doc = "ev argument must be already initialized by event_assign() or event_new()"]
    #[doc = "and may not be used"]
    #[doc = "in calls to event_assign() until it is no longer pending."]
    #[doc = ""]
    #[doc = "If the event in the ev argument already has a scheduled timeout, calling"]
    #[doc = "event_add() replaces the old timeout with the new one if tv is non-NULL."]
    #[doc = ""]
    #[doc = "@param ev an event struct initialized via event_assign() or event_new()"]
    #[doc = "@param timeout the maximum amount of time to wait for the event, or NULL"]
    #[doc = "to wait forever"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see event_del(), event_assign(), event_new()"]
    pub fn event_add(ev: *mut event, timeout: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Remove a timer from a pending event without removing the event itself."]
    #[doc = ""]
    #[doc = "If the event has a scheduled timeout, this function unschedules it but"]
    #[doc = "leaves the event otherwise pending."]
    #[doc = ""]
    #[doc = "@param ev an event struct initialized via event_assign() or event_new()"]
    #[doc = "@return 0 on success, or -1 if an error occurred."]
    pub fn event_remove_timer(ev: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Remove an event from the set of monitored events."]
    #[doc = ""]
    #[doc = "The function event_del() will cancel the event in the argument ev.  If the"]
    #[doc = "event has already executed or has never been added the call will have no"]
    #[doc = "effect."]
    #[doc = ""]
    #[doc = "@param ev an event struct to be removed from the working set"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see event_add()"]
    pub fn event_del(arg1: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "As event_del(), but never blocks while the event's callback is running"]
    #[doc = "in another thread, even if the event was constructed without the"]
    #[doc = "EV_FINALIZE flag."]
    pub fn event_del_noblock(ev: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "As event_del(), but always blocks while the event's callback is running"]
    #[doc = "in another thread, even if the event was constructed with the"]
    #[doc = "EV_FINALIZE flag."]
    pub fn event_del_block(ev: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Make an event active."]
    #[doc = ""]
    #[doc = "You can use this function on a pending or a non-pending event to make it"]
    #[doc = "active, so that its callback will be run by event_base_dispatch() or"]
    #[doc = "event_base_loop()."]
    #[doc = ""]
    #[doc = "One common use in multithreaded programs is to wake the thread running"]
    #[doc = "event_base_loop() from another thread."]
    #[doc = ""]
    #[doc = "@param ev an event to make active."]
    #[doc = "@param res a set of flags to pass to the event's callback."]
    #[doc = "@param ncalls an obsolete argument: this is ignored."]
    pub fn event_active(
        ev: *mut event,
        res: ::std::os::raw::c_int,
        ncalls: ::std::os::raw::c_short,
    );
}
extern "C" {
    #[doc = "Checks if a specific event is pending or scheduled."]
    #[doc = ""]
    #[doc = "@param ev an event struct previously passed to event_add()"]
    #[doc = "@param events the requested event type; any of EV_TIMEOUT|EV_READ|"]
    #[doc = "EV_WRITE|EV_SIGNAL"]
    #[doc = "@param tv if this field is not NULL, and the event has a timeout,"]
    #[doc = "this field is set to hold the time at which the timeout will"]
    #[doc = "expire."]
    #[doc = ""]
    #[doc = "@return true if the event is pending on any of the events in 'what', (that"]
    #[doc = "is to say, it has been added), or 0 if the event is not added."]
    pub fn event_pending(
        ev: *const event,
        events: ::std::os::raw::c_short,
        tv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "If called from within the callback for an event, returns that event."]
    #[doc = ""]
    #[doc = "The behavior of this function is not defined when called from outside the"]
    #[doc = "callback function for an event."]
    pub fn event_base_get_running_event(base: *mut event_base) -> *mut event;
}
extern "C" {
    #[doc = "Test if an event structure might be initialized."]
    #[doc = ""]
    #[doc = "The event_initialized() function can be used to check if an event has been"]
    #[doc = "initialized."]
    #[doc = ""]
    #[doc = "Warning: This function is only useful for distinguishing a zeroed-out"]
    #[doc = "piece of memory from an initialized event, it can easily be confused by"]
    #[doc = "uninitialized memory.  Thus, it should ONLY be used to distinguish an"]
    #[doc = "initialized event from zero."]
    #[doc = ""]
    #[doc = "@param ev an event structure to be tested"]
    #[doc = "@return 1 if the structure might be initialized, or 0 if it has not been"]
    #[doc = "initialized"]
    pub fn event_initialized(ev: *const event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the socket or signal assigned to an event, or -1 if the event has"]
    #[doc = "no socket."]
    pub fn event_get_fd(ev: *const event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the event_base associated with an event."]
    pub fn event_get_base(ev: *const event) -> *mut event_base;
}
extern "C" {
    #[doc = "Return the events (EV_READ, EV_WRITE, etc) assigned to an event."]
    pub fn event_get_events(ev: *const event) -> ::std::os::raw::c_short;
}
extern "C" {
    #[doc = "Return the callback assigned to an event."]
    pub fn event_get_callback(ev: *const event) -> event_callback_fn;
}
extern "C" {
    #[doc = "Return the callback argument assigned to an event."]
    pub fn event_get_callback_arg(ev: *const event) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Return the priority of an event."]
    #[doc = "@see event_priority_init(), event_get_priority()"]
    pub fn event_get_priority(ev: *const event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Extract _all_ of arguments given to construct a given event.  The"]
    #[doc = "event_base is copied into *base_out, the fd is copied into *fd_out, and so"]
    #[doc = "on."]
    #[doc = ""]
    #[doc = "If any of the \"_out\" arguments is NULL, it will be ignored."]
    pub fn event_get_assignment(
        event: *const event,
        base_out: *mut *mut event_base,
        fd_out: *mut ::std::os::raw::c_int,
        events_out: *mut ::std::os::raw::c_short,
        callback_out: *mut event_callback_fn,
        arg_out: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Return the size of struct event that the Libevent library was compiled"]
    #[doc = "with."]
    #[doc = ""]
    #[doc = "This will be NO GREATER than sizeof(struct event) if you're running with"]
    #[doc = "the same version of Libevent that your application was built with, but"]
    #[doc = "otherwise might not."]
    #[doc = ""]
    #[doc = "Note that it might be SMALLER than sizeof(struct event) if some future"]
    #[doc = "version of Libevent adds extra padding to the end of struct event."]
    #[doc = "We might do this to help ensure ABI-compatibility between different"]
    #[doc = "versions of Libevent."]
    pub fn event_get_struct_event_size() -> size_t;
}
extern "C" {
    #[doc = "Get the Libevent version."]
    #[doc = ""]
    #[doc = "Note that this will give you the version of the library that you're"]
    #[doc = "currently linked against, not the version of the headers that you've"]
    #[doc = "compiled against."]
    #[doc = ""]
    #[doc = "@return a string containing the version number of Libevent"]
    pub fn event_get_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Return a numeric representation of Libevent's version."]
    #[doc = ""]
    #[doc = "Note that this will give you the version of the library that you're"]
    #[doc = "currently linked against, not the version of the headers you've used to"]
    #[doc = "compile."]
    #[doc = ""]
    #[doc = "The format uses one byte each for the major, minor, and patchlevel parts of"]
    #[doc = "the version number.  The low-order byte is unused.  For example, version"]
    #[doc = "2.0.1-alpha has a numeric representation of 0x02000100"]
    pub fn event_get_version_number() -> u32;
}
extern "C" {
    #[doc = "Set the number of different event priorities"]
    #[doc = ""]
    #[doc = "By default Libevent schedules all active events with the same priority."]
    #[doc = "However, some time it is desirable to process some events with a higher"]
    #[doc = "priority than others.  For that reason, Libevent supports strict priority"]
    #[doc = "queues.  Active events with a lower priority are always processed before"]
    #[doc = "events with a higher priority."]
    #[doc = ""]
    #[doc = "The number of different priorities can be set initially with the"]
    #[doc = "event_base_priority_init() function.  This function should be called"]
    #[doc = "before the first call to event_base_dispatch().  The"]
    #[doc = "event_priority_set() function can be used to assign a priority to an"]
    #[doc = "event.  By default, Libevent assigns the middle priority to all events"]
    #[doc = "unless their priority is explicitly set."]
    #[doc = ""]
    #[doc = "Note that urgent-priority events can starve less-urgent events: after"]
    #[doc = "running all urgent-priority callbacks, Libevent checks for more urgent"]
    #[doc = "events again, before running less-urgent events.  Less-urgent events"]
    #[doc = "will not have their callbacks run until there are no events more urgent"]
    #[doc = "than them that want to be active."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_base_new()"]
    #[doc = "@param npriorities the maximum number of priorities"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see event_priority_set()"]
    pub fn event_base_priority_init(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the number of different event priorities."]
    #[doc = ""]
    #[doc = "@param eb the event_base structure returned by event_base_new()"]
    #[doc = "@return Number of different event priorities"]
    #[doc = "@see event_base_priority_init()"]
    pub fn event_base_get_npriorities(eb: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Assign a priority to an event."]
    #[doc = ""]
    #[doc = "@param ev an event struct"]
    #[doc = "@param priority the new priority to be assigned"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see event_priority_init(), event_get_priority()"]
    pub fn event_priority_set(
        arg1: *mut event,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Prepare an event_base to use a large number of timeouts with the same"]
    #[doc = "duration."]
    #[doc = ""]
    #[doc = "Libevent's default scheduling algorithm is optimized for having a large"]
    #[doc = "number of timeouts with their durations more or less randomly"]
    #[doc = "distributed.  But if you have a large number of timeouts that all have"]
    #[doc = "the same duration (for example, if you have a large number of"]
    #[doc = "connections that all have a 10-second timeout), then you can improve"]
    #[doc = "Libevent's performance by telling Libevent about it."]
    #[doc = ""]
    #[doc = "To do this, call this function with the common duration.  It will return a"]
    #[doc = "pointer to a different, opaque timeout value.  (Don't depend on its actual"]
    #[doc = "contents!)  When you use this timeout value in event_add(), Libevent will"]
    #[doc = "schedule the event more efficiently."]
    #[doc = ""]
    #[doc = "(This optimization probably will not be worthwhile until you have thousands"]
    #[doc = "or tens of thousands of events with the same timeout.)"]
    pub fn event_base_init_common_timeout(
        base: *mut event_base,
        duration: *const timeval,
    ) -> *const timeval;
}
extern "C" {
    #[doc = "Override the functions that Libevent uses for memory management."]
    #[doc = ""]
    #[doc = "Usually, Libevent uses the standard libc functions malloc, realloc, and"]
    #[doc = "free to allocate memory.  Passing replacements for those functions to"]
    #[doc = "event_set_mem_functions() overrides this behavior."]
    #[doc = ""]
    #[doc = "Note that all memory returned from Libevent will be allocated by the"]
    #[doc = "replacement functions rather than by malloc() and realloc().  Thus, if you"]
    #[doc = "have replaced those functions, it will not be appropriate to free() memory"]
    #[doc = "that you get from Libevent.  Instead, you must use the free_fn replacement"]
    #[doc = "that you provided."]
    #[doc = ""]
    #[doc = "Note also that if you are going to call this function, you should do so"]
    #[doc = "before any call to any Libevent function that does allocation."]
    #[doc = "Otherwise, those functions will allocate their memory using malloc(), but"]
    #[doc = "then later free it using your provided free_fn."]
    #[doc = ""]
    #[doc = "@param malloc_fn A replacement for malloc."]
    #[doc = "@param realloc_fn A replacement for realloc"]
    #[doc = "@param free_fn A replacement for free."]
    pub fn event_set_mem_functions(
        malloc_fn: ::std::option::Option<
            unsafe extern "C" fn(sz: size_t) -> *mut ::std::os::raw::c_void,
        >,
        realloc_fn: ::std::option::Option<
            unsafe extern "C" fn(
                ptr: *mut ::std::os::raw::c_void,
                sz: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        free_fn: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = "Writes a human-readable description of all inserted and/or active"]
    #[doc = "events to a provided stdio stream."]
    #[doc = ""]
    #[doc = "This is intended for debugging; its format is not guaranteed to be the same"]
    #[doc = "between libevent versions."]
    #[doc = ""]
    #[doc = "@param base An event_base on which to scan the events."]
    #[doc = "@param output A stdio file to write on."]
    pub fn event_base_dump_events(arg1: *mut event_base, arg2: *mut FILE);
}
extern "C" {
    #[doc = "Activates all pending events for the given fd and event mask."]
    #[doc = ""]
    #[doc = "This function activates pending events only.  Events which have not been"]
    #[doc = "added will not become active."]
    #[doc = ""]
    #[doc = "@param base the event_base on which to activate the events."]
    #[doc = "@param fd An fd to active events on."]
    #[doc = "@param events One or more of EV_{READ,WRITE,TIMEOUT}."]
    pub fn event_base_active_by_fd(
        base: *mut event_base,
        fd: ::std::os::raw::c_int,
        events: ::std::os::raw::c_short,
    );
}
extern "C" {
    #[doc = "Activates all pending signals with a given signal number"]
    #[doc = ""]
    #[doc = "This function activates pending events only.  Events which have not been"]
    #[doc = "added will not become active."]
    #[doc = ""]
    #[doc = "@param base the event_base on which to activate the events."]
    #[doc = "@param fd The signal to active events on."]
    pub fn event_base_active_by_signal(base: *mut event_base, sig: ::std::os::raw::c_int);
}
#[doc = " Callback for iterating events in an event base via event_base_foreach_event"]
pub type event_base_foreach_event_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const event_base,
        arg2: *const event,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = "Iterate over all added or active events events in an event loop, and invoke"]
    #[doc = "a given callback on each one."]
    #[doc = ""]
    #[doc = "The callback must not call any function that modifies the event base, that"]
    #[doc = "modifies any event in the event base, or that adds or removes any event to"]
    #[doc = "the event base.  Doing so is unsupported and will lead to undefined"]
    #[doc = "behavior -- likely, to crashes."]
    #[doc = ""]
    #[doc = "event_base_foreach_event() holds a lock on the event_base() for the whole"]
    #[doc = "time it's running: slow callbacks are not advisable."]
    #[doc = ""]
    #[doc = "Note that Libevent adds some events of its own to make pieces of its"]
    #[doc = "functionality work.  You must not assume that the only events you'll"]
    #[doc = "encounter will be the ones you added yourself."]
    #[doc = ""]
    #[doc = "The callback function must return 0 to continue iteration, or some other"]
    #[doc = "integer to stop iterating."]
    #[doc = ""]
    #[doc = "@param base An event_base on which to scan the events."]
    #[doc = "@param fn   A callback function to receive the events."]
    #[doc = "@param arg  An argument passed to the callback function."]
    #[doc = "@return 0 if we iterated over every event, or the value returned by the"]
    #[doc = "callback function if the loop exited early."]
    pub fn event_base_foreach_event(
        base: *mut event_base,
        fn_: event_base_foreach_event_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets 'tv' to the current time (as returned by gettimeofday()),"]
    #[doc = "looking at the cached value in 'base' if possible, and calling"]
    #[doc = "gettimeofday() or clock_gettime() as appropriate if there is no"]
    #[doc = "cached time."]
    #[doc = ""]
    #[doc = "Generally, this value will only be cached while actually"]
    #[doc = "processing event callbacks, and may be very inaccurate if your"]
    #[doc = "callbacks take a long time to execute."]
    #[doc = ""]
    #[doc = "Returns 0 on success, negative on failure."]
    pub fn event_base_gettimeofday_cached(
        base: *mut event_base,
        tv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update cached_tv in the 'base' to the current time"]
    #[doc = ""]
    #[doc = " You can use this function is useful for selectively increasing"]
    #[doc = " the accuracy of the cached time value in 'base' during callbacks"]
    #[doc = " that take a long time to execute."]
    #[doc = ""]
    #[doc = " This function has no effect if the base is currently not in its"]
    #[doc = " event loop, or if timeval caching is disabled via"]
    #[doc = " EVENT_BASE_FLAG_NO_CACHE_TIME."]
    #[doc = ""]
    #[doc = " @return 0 on success, -1 on failure"]
    pub fn event_base_update_cache_time(base: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release up all globally-allocated resources allocated by Libevent."]
    #[doc = ""]
    #[doc = "This function does not free developer-controlled resources like"]
    #[doc = "event_bases, events, bufferevents, listeners, and so on.  It only releases"]
    #[doc = "resources like global locks that there is no other way to free."]
    #[doc = ""]
    #[doc = "It is not actually necessary to call this function before exit: every"]
    #[doc = "resource that it frees would be released anyway on exit.  It mainly exists"]
    #[doc = "so that resource-leak debugging tools don't see Libevent as holding"]
    #[doc = "resources at exit."]
    #[doc = ""]
    #[doc = "You should only call this function when no other Libevent functions will"]
    #[doc = "be invoked -- e.g., when cleanly exiting a program."]
    pub fn libevent_global_shutdown();
}
extern "C" {
    #[doc = "Initialize the event API."]
    #[doc = ""]
    #[doc = "The event API needs to be initialized with event_init() before it can be"]
    #[doc = "used.  Sets the global current base that gets used for events that have no"]
    #[doc = "base associated with them."]
    #[doc = ""]
    #[doc = "@deprecated This function is deprecated because it replaces the \"current\""]
    #[doc = "event_base, and is totally unsafe for multithreaded use.  The replacement"]
    #[doc = "is event_base_new()."]
    #[doc = ""]
    #[doc = "@see event_base_set(), event_base_new()"]
    pub fn event_init() -> *mut event_base;
}
extern "C" {
    #[doc = "Loop to process events."]
    #[doc = ""]
    #[doc = "Like event_base_dispatch(), but uses the \"current\" base."]
    #[doc = ""]
    #[doc = "@deprecated This function is deprecated because it is easily confused by"]
    #[doc = "multiple calls to event_init(), and because it is not safe for"]
    #[doc = "multithreaded use.  The replacement is event_base_dispatch()."]
    #[doc = ""]
    #[doc = "@see event_base_dispatch(), event_init()"]
    pub fn event_dispatch() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Handle events."]
    #[doc = ""]
    #[doc = "This function behaves like event_base_loop(), but uses the \"current\" base"]
    #[doc = ""]
    #[doc = "@deprecated This function is deprecated because it uses the event base from"]
    #[doc = "the last call to event_init, and is therefore not safe for multithreaded"]
    #[doc = "use.  The replacement is event_base_loop()."]
    #[doc = ""]
    #[doc = "@see event_base_loop(), event_init()"]
    pub fn event_loop(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Exit the event loop after the specified time."]
    #[doc = ""]
    #[doc = "This function behaves like event_base_loopexit(), except that it uses the"]
    #[doc = "\"current\" base."]
    #[doc = ""]
    #[doc = "@deprecated This function is deprecated because it uses the event base from"]
    #[doc = "the last call to event_init, and is therefore not safe for multithreaded"]
    #[doc = "use.  The replacement is event_base_loopexit()."]
    #[doc = ""]
    #[doc = "@see event_init, event_base_loopexit()"]
    pub fn event_loopexit(arg1: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Abort the active event_loop() immediately."]
    #[doc = ""]
    #[doc = "This function behaves like event_base_loopbreakt(), except that it uses the"]
    #[doc = "\"current\" base."]
    #[doc = ""]
    #[doc = "@deprecated This function is deprecated because it uses the event base from"]
    #[doc = "the last call to event_init, and is therefore not safe for multithreaded"]
    #[doc = "use.  The replacement is event_base_loopbreak()."]
    #[doc = ""]
    #[doc = "@see event_base_loopbreak(), event_init()"]
    pub fn event_loopbreak() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Schedule a one-time event to occur."]
    #[doc = ""]
    #[doc = "@deprecated This function is obsolete, and has been replaced by"]
    #[doc = "event_base_once(). Its use is deprecated because it relies on the"]
    #[doc = "\"current\" base configured by event_init()."]
    #[doc = ""]
    #[doc = "@see event_base_once()"]
    pub fn event_once(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_short,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_short,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the kernel event notification mechanism used by Libevent."]
    #[doc = ""]
    #[doc = "@deprecated This function is obsolete, and has been replaced by"]
    #[doc = "event_base_get_method(). Its use is deprecated because it relies on the"]
    #[doc = "\"current\" base configured by event_init()."]
    #[doc = ""]
    #[doc = "@see event_base_get_method()"]
    pub fn event_get_method() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Set the number of different event priorities."]
    #[doc = ""]
    #[doc = "@deprecated This function is deprecated because it is easily confused by"]
    #[doc = "multiple calls to event_init(), and because it is not safe for"]
    #[doc = "multithreaded use.  The replacement is event_base_priority_init()."]
    #[doc = ""]
    #[doc = "@see event_base_priority_init()"]
    pub fn event_priority_init(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Prepare an event structure to be added."]
    #[doc = ""]
    #[doc = "@deprecated event_set() is not recommended for new code, because it requires"]
    #[doc = "a subsequent call to event_base_set() to be safe under most circumstances."]
    #[doc = "Use event_assign() or event_new() instead."]
    pub fn event_set(
        arg1: *mut event,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_short,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_short,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        arg5: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
#[doc = "An evbuffer is an opaque data type for efficiently buffering data to be"]
#[doc = "sent or received on the network."]
#[doc = ""]
#[doc = "@see event2/event.h for more information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer {
    _unused: [u8; 0],
}
#[doc = "Pointer to a position within an evbuffer."]
#[doc = ""]
#[doc = "Used when repeatedly searching through a buffer.  Calling any function"]
#[doc = "that modifies or re-packs the buffer contents may invalidate all"]
#[doc = "evbuffer_ptrs for that buffer.  Do not modify or contruct these values"]
#[doc = "except with evbuffer_ptr_set."]
#[doc = ""]
#[doc = "An evbuffer_ptr can represent any position from the start of a buffer up"]
#[doc = "to a position immediately after the end of a buffer."]
#[doc = ""]
#[doc = "@see evbuffer_ptr_set()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_ptr {
    pub pos: ssize_t,
    pub internal_: evbuffer_ptr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_ptr__bindgen_ty_1 {
    pub chain: *mut ::std::os::raw::c_void,
    pub pos_in_chain: size_t,
}
#[test]
fn bindgen_test_layout_evbuffer_ptr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<evbuffer_ptr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(evbuffer_ptr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<evbuffer_ptr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(evbuffer_ptr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evbuffer_ptr__bindgen_ty_1>())).chain as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_ptr__bindgen_ty_1),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evbuffer_ptr__bindgen_ty_1>())).pos_in_chain as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_ptr__bindgen_ty_1),
            "::",
            stringify!(pos_in_chain)
        )
    );
}
#[test]
fn bindgen_test_layout_evbuffer_ptr() {
    assert_eq!(
        ::std::mem::size_of::<evbuffer_ptr>(),
        24usize,
        concat!("Size of: ", stringify!(evbuffer_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<evbuffer_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(evbuffer_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evbuffer_ptr>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_ptr),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evbuffer_ptr>())).internal_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_ptr),
            "::",
            stringify!(internal_)
        )
    );
}
extern "C" {
    #[doc = "Allocate storage for a new evbuffer."]
    #[doc = ""]
    #[doc = "@return a pointer to a newly allocated evbuffer struct, or NULL if an error"]
    #[doc = "occurred"]
    pub fn evbuffer_new() -> *mut evbuffer;
}
extern "C" {
    #[doc = "Deallocate storage for an evbuffer."]
    #[doc = ""]
    #[doc = "@param buf pointer to the evbuffer to be freed"]
    pub fn evbuffer_free(buf: *mut evbuffer);
}
extern "C" {
    #[doc = "Enable locking on an evbuffer so that it can safely be used by multiple"]
    #[doc = "threads at the same time."]
    #[doc = ""]
    #[doc = "NOTE: when locking is enabled, the lock will be held when callbacks are"]
    #[doc = "invoked.  This could result in deadlock if you aren't careful.  Plan"]
    #[doc = "accordingly!"]
    #[doc = ""]
    #[doc = "@param buf An evbuffer to make lockable."]
    #[doc = "@param lock A lock object, or NULL if we should allocate our own."]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evbuffer_enable_locking(
        buf: *mut evbuffer,
        lock: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Acquire the lock on an evbuffer.  Has no effect if locking was not enabled"]
    #[doc = "with evbuffer_enable_locking."]
    pub fn evbuffer_lock(buf: *mut evbuffer);
}
extern "C" {
    #[doc = "Release the lock on an evbuffer.  Has no effect if locking was not enabled"]
    #[doc = "with evbuffer_enable_locking."]
    pub fn evbuffer_unlock(buf: *mut evbuffer);
}
extern "C" {
    #[doc = " Change the flags that are set for an evbuffer by adding more."]
    #[doc = ""]
    #[doc = " @param buffer the evbuffer that the callback is watching."]
    #[doc = " @param cb the callback whose status we want to change."]
    #[doc = " @param flags One or more EVBUFFER_FLAG_* options"]
    #[doc = " @return 0 on success, -1 on failure."]
    pub fn evbuffer_set_flags(buf: *mut evbuffer, flags: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the flags that are set for an evbuffer by removing some."]
    #[doc = ""]
    #[doc = " @param buffer the evbuffer that the callback is watching."]
    #[doc = " @param cb the callback whose status we want to change."]
    #[doc = " @param flags One or more EVBUFFER_FLAG_* options"]
    #[doc = " @return 0 on success, -1 on failure."]
    pub fn evbuffer_clear_flags(buf: *mut evbuffer, flags: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the total number of bytes stored in the evbuffer"]
    #[doc = ""]
    #[doc = "@param buf pointer to the evbuffer"]
    #[doc = "@return the number of bytes stored in the evbuffer"]
    pub fn evbuffer_get_length(buf: *const evbuffer) -> size_t;
}
extern "C" {
    #[doc = "Returns the number of contiguous available bytes in the first buffer chain."]
    #[doc = ""]
    #[doc = "This is useful when processing data that might be split into multiple"]
    #[doc = "chains, or that might all be in the first chain.  Calls to"]
    #[doc = "evbuffer_pullup() that cause reallocation and copying of data can thus be"]
    #[doc = "avoided."]
    #[doc = ""]
    #[doc = "@param buf pointer to the evbuffer"]
    #[doc = "@return 0 if no data is available, otherwise the number of available bytes"]
    #[doc = "in the first buffer chain."]
    pub fn evbuffer_get_contiguous_space(buf: *const evbuffer) -> size_t;
}
extern "C" {
    #[doc = "Expands the available space in an evbuffer."]
    #[doc = ""]
    #[doc = "Expands the available space in the evbuffer to at least datlen, so that"]
    #[doc = "appending datlen additional bytes will not require any new allocations."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer to be expanded"]
    #[doc = "@param datlen the new minimum length requirement"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    pub fn evbuffer_expand(buf: *mut evbuffer, datlen: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Reserves space in the last chain or chains of an evbuffer."]
    #[doc = ""]
    #[doc = "Makes space available in the last chain or chains of an evbuffer that can"]
    #[doc = "be arbitrarily written to by a user.  The space does not become"]
    #[doc = "available for reading until it has been committed with"]
    #[doc = "evbuffer_commit_space()."]
    #[doc = ""]
    #[doc = "The space is made available as one or more extents, represented by"]
    #[doc = "an initial pointer and a length.  You can force the memory to be"]
    #[doc = "available as only one extent.  Allowing more extents, however, makes the"]
    #[doc = "function more efficient."]
    #[doc = ""]
    #[doc = "Multiple subsequent calls to this function will make the same space"]
    #[doc = "available until evbuffer_commit_space() has been called."]
    #[doc = ""]
    #[doc = "It is an error to do anything that moves around the buffer's internal"]
    #[doc = "memory structures before committing the space."]
    #[doc = ""]
    #[doc = "NOTE: The code currently does not ever use more than two extents."]
    #[doc = "This may change in future versions."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer in which to reserve space."]
    #[doc = "@param size how much space to make available, at minimum.  The"]
    #[doc = "total length of the extents may be greater than the requested"]
    #[doc = "length."]
    #[doc = "@param vec an array of one or more evbuffer_iovec structures to"]
    #[doc = "hold pointers to the reserved extents of memory."]
    #[doc = "@param n_vec The length of the vec array.  Must be at least 1;"]
    #[doc = "2 is more efficient."]
    #[doc = "@return the number of provided extents, or -1 on error."]
    #[doc = "@see evbuffer_commit_space()"]
    pub fn evbuffer_reserve_space(
        buf: *mut evbuffer,
        size: ssize_t,
        vec: *mut iovec,
        n_vec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Commits previously reserved space."]
    #[doc = ""]
    #[doc = "Commits some of the space previously reserved with"]
    #[doc = "evbuffer_reserve_space().  It then becomes available for reading."]
    #[doc = ""]
    #[doc = "This function may return an error if the pointer in the extents do"]
    #[doc = "not match those returned from evbuffer_reserve_space, or if data"]
    #[doc = "has been added to the buffer since the space was reserved."]
    #[doc = ""]
    #[doc = "If you want to commit less data than you got reserved space for,"]
    #[doc = "modify the iov_len pointer of the appropriate extent to a smaller"]
    #[doc = "value.  Note that you may have received more space than you"]
    #[doc = "requested if it was available!"]
    #[doc = ""]
    #[doc = "@param buf the evbuffer in which to reserve space."]
    #[doc = "@param vec one or two extents returned by evbuffer_reserve_space."]
    #[doc = "@param n_vecs the number of extents."]
    #[doc = "@return 0 on success, -1 on error"]
    #[doc = "@see evbuffer_reserve_space()"]
    pub fn evbuffer_commit_space(
        buf: *mut evbuffer,
        vec: *mut iovec,
        n_vecs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Append data to the end of an evbuffer."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer to be appended to"]
    #[doc = "@param data pointer to the beginning of the data buffer"]
    #[doc = "@param datlen the number of bytes to be copied from the data buffer"]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evbuffer_add(
        buf: *mut evbuffer,
        data: *const ::std::os::raw::c_void,
        datlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Read data from an evbuffer and drain the bytes read."]
    #[doc = ""]
    #[doc = "If more bytes are requested than are available in the evbuffer, we"]
    #[doc = "only extract as many bytes as were available."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer to be read from"]
    #[doc = "@param data the destination buffer to store the result"]
    #[doc = "@param datlen the maximum size of the destination buffer"]
    #[doc = "@return the number of bytes read, or -1 if we can't drain the buffer."]
    pub fn evbuffer_remove(
        buf: *mut evbuffer,
        data: *mut ::std::os::raw::c_void,
        datlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Read data from an evbuffer, and leave the buffer unchanged."]
    #[doc = ""]
    #[doc = "If more bytes are requested than are available in the evbuffer, we"]
    #[doc = "only extract as many bytes as were available."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer to be read from"]
    #[doc = "@param data_out the destination buffer to store the result"]
    #[doc = "@param datlen the maximum size of the destination buffer"]
    #[doc = "@return the number of bytes read, or -1 if we can't drain the buffer."]
    pub fn evbuffer_copyout(
        buf: *mut evbuffer,
        data_out: *mut ::std::os::raw::c_void,
        datlen: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = "Read data from the middle of an evbuffer, and leave the buffer unchanged."]
    #[doc = ""]
    #[doc = "If more bytes are requested than are available in the evbuffer, we"]
    #[doc = "only extract as many bytes as were available."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer to be read from"]
    #[doc = "@param pos the position to start reading from"]
    #[doc = "@param data_out the destination buffer to store the result"]
    #[doc = "@param datlen the maximum size of the destination buffer"]
    #[doc = "@return the number of bytes read, or -1 if we can't drain the buffer."]
    pub fn evbuffer_copyout_from(
        buf: *mut evbuffer,
        pos: *const evbuffer_ptr,
        data_out: *mut ::std::os::raw::c_void,
        datlen: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = "Read data from an evbuffer into another evbuffer, draining"]
    #[doc = "the bytes from the source buffer.  This function avoids copy"]
    #[doc = "operations to the extent possible."]
    #[doc = ""]
    #[doc = "If more bytes are requested than are available in src, the src"]
    #[doc = "buffer is drained completely."]
    #[doc = ""]
    #[doc = "@param src the evbuffer to be read from"]
    #[doc = "@param dst the destination evbuffer to store the result into"]
    #[doc = "@param datlen the maximum numbers of bytes to transfer"]
    #[doc = "@return the number of bytes read"]
    pub fn evbuffer_remove_buffer(
        src: *mut evbuffer,
        dst: *mut evbuffer,
        datlen: size_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Any sequence of CR and LF characters is acceptable as an"]
#[doc = " EOL."]
#[doc = ""]
#[doc = " Note that this style can produce ambiguous results: the"]
#[doc = " sequence \"CRLF\" will be treated as a single EOL if it is"]
#[doc = " all in the buffer at once, but if you first read a CR from"]
#[doc = " the network and later read an LF from the network, it will"]
#[doc = " be treated as two EOLs."]
pub const evbuffer_eol_style_EVBUFFER_EOL_ANY: evbuffer_eol_style = 0;
#[doc = " An EOL is an LF, optionally preceded by a CR.  This style is"]
#[doc = " most useful for implementing text-based internet protocols."]
pub const evbuffer_eol_style_EVBUFFER_EOL_CRLF: evbuffer_eol_style = 1;
#[doc = " An EOL is a CR followed by an LF."]
pub const evbuffer_eol_style_EVBUFFER_EOL_CRLF_STRICT: evbuffer_eol_style = 2;
#[doc = " An EOL is a LF."]
pub const evbuffer_eol_style_EVBUFFER_EOL_LF: evbuffer_eol_style = 3;
#[doc = " An EOL is a NUL character (that is, a single byte with value 0)"]
pub const evbuffer_eol_style_EVBUFFER_EOL_NUL: evbuffer_eol_style = 4;
#[doc = " Used to tell evbuffer_readln what kind of line-ending to look for."]
pub type evbuffer_eol_style = u32;
extern "C" {
    #[doc = " Read a single line from an evbuffer."]
    #[doc = ""]
    #[doc = " Reads a line terminated by an EOL as determined by the evbuffer_eol_style"]
    #[doc = " argument.  Returns a newly allocated nul-terminated string; the caller must"]
    #[doc = " free the returned value.  The EOL is not included in the returned string."]
    #[doc = ""]
    #[doc = " @param buffer the evbuffer to read from"]
    #[doc = " @param n_read_out if non-NULL, points to a size_t that is set to the"]
    #[doc = "       number of characters in the returned string.  This is useful for"]
    #[doc = "       strings that can contain NUL characters."]
    #[doc = " @param eol_style the style of line-ending to use."]
    #[doc = " @return pointer to a single line, or NULL if an error occurred"]
    pub fn evbuffer_readln(
        buffer: *mut evbuffer,
        n_read_out: *mut size_t,
        eol_style: evbuffer_eol_style,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Move all data from one evbuffer into another evbuffer."]
    #[doc = ""]
    #[doc = "This is a destructive add.  The data from one buffer moves into"]
    #[doc = "the other buffer.  However, no unnecessary memory copies occur."]
    #[doc = ""]
    #[doc = "@param outbuf the output buffer"]
    #[doc = "@param inbuf the input buffer"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = ""]
    #[doc = "@see evbuffer_remove_buffer()"]
    pub fn evbuffer_add_buffer(
        outbuf: *mut evbuffer,
        inbuf: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Copy data from one evbuffer into another evbuffer."]
    #[doc = ""]
    #[doc = "This is a non-destructive add.  The data from one buffer is copied"]
    #[doc = "into the other buffer.  However, no unnecessary memory copies occur."]
    #[doc = ""]
    #[doc = "Note that buffers already containing buffer references can't be added"]
    #[doc = "to other buffers."]
    #[doc = ""]
    #[doc = "@param outbuf the output buffer"]
    #[doc = "@param inbuf the input buffer"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    pub fn evbuffer_add_buffer_reference(
        outbuf: *mut evbuffer,
        inbuf: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
#[doc = "A cleanup function for a piece of memory added to an evbuffer by"]
#[doc = "reference."]
#[doc = ""]
#[doc = "@see evbuffer_add_reference()"]
pub type evbuffer_ref_cleanup_cb = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_void,
        datalen: size_t,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Reference memory into an evbuffer without copying."]
    #[doc = ""]
    #[doc = "The memory needs to remain valid until all the added data has been"]
    #[doc = "read.  This function keeps just a reference to the memory without"]
    #[doc = "actually incurring the overhead of a copy."]
    #[doc = ""]
    #[doc = "@param outbuf the output buffer"]
    #[doc = "@param data the memory to reference"]
    #[doc = "@param datlen how memory to reference"]
    #[doc = "@param cleanupfn callback to be invoked when the memory is no longer"]
    #[doc = "referenced by this evbuffer."]
    #[doc = "@param cleanupfn_arg optional argument to the cleanup callback"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    pub fn evbuffer_add_reference(
        outbuf: *mut evbuffer,
        data: *const ::std::os::raw::c_void,
        datlen: size_t,
        cleanupfn: evbuffer_ref_cleanup_cb,
        cleanupfn_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Copy data from a file into the evbuffer for writing to a socket."]
    #[doc = ""]
    #[doc = "This function avoids unnecessary data copies between userland and"]
    #[doc = "kernel.  If sendfile is available and the EVBUFFER_FLAG_DRAINS_TO_FD"]
    #[doc = "flag is set, it uses those functions.  Otherwise, it tries to use"]
    #[doc = "mmap (or CreateFileMapping on Windows)."]
    #[doc = ""]
    #[doc = "The function owns the resulting file descriptor and will close it"]
    #[doc = "when finished transferring data."]
    #[doc = ""]
    #[doc = "The results of using evbuffer_remove() or evbuffer_pullup() on"]
    #[doc = "evbuffers whose data was added using this function are undefined."]
    #[doc = ""]
    #[doc = "For more fine-grained control, use evbuffer_add_file_segment."]
    #[doc = ""]
    #[doc = "@param outbuf the output buffer"]
    #[doc = "@param fd the file descriptor"]
    #[doc = "@param offset the offset from which to read data"]
    #[doc = "@param length how much data to read, or -1 to read as much as possible."]
    #[doc = "(-1 requires that 'fd' support fstat.)"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    pub fn evbuffer_add_file(
        outbuf: *mut evbuffer,
        fd: ::std::os::raw::c_int,
        offset: i64,
        length: i64,
    ) -> ::std::os::raw::c_int;
}
#[doc = "An evbuffer_file_segment holds a reference to a range of a file --"]
#[doc = "possibly the whole file! -- for use in writing from an evbuffer to a"]
#[doc = "socket.  It could be implemented with mmap, sendfile, splice, or (if all"]
#[doc = "else fails) by just pulling all the data into RAM.  A single"]
#[doc = "evbuffer_file_segment can be added more than once, and to more than one"]
#[doc = "evbuffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_file_segment {
    _unused: [u8; 0],
}
#[doc = "A cleanup function for a evbuffer_file_segment added to an evbuffer"]
#[doc = "for reference."]
pub type evbuffer_file_segment_cleanup_cb = ::std::option::Option<
    unsafe extern "C" fn(
        seg: *const evbuffer_file_segment,
        flags: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Create and return a new evbuffer_file_segment for reading data from a"]
    #[doc = "file and sending it out via an evbuffer."]
    #[doc = ""]
    #[doc = "This function avoids unnecessary data copies between userland and"]
    #[doc = "kernel.  Where available, it uses sendfile or splice."]
    #[doc = ""]
    #[doc = "The file descriptor must not be closed so long as any evbuffer is using"]
    #[doc = "this segment."]
    #[doc = ""]
    #[doc = "The results of using evbuffer_remove() or evbuffer_pullup() or any other"]
    #[doc = "function that reads bytes from an evbuffer on any evbuffer containing"]
    #[doc = "the newly returned segment are undefined, unless you pass the"]
    #[doc = "EVBUF_FS_DISABLE_SENDFILE flag to this function."]
    #[doc = ""]
    #[doc = "@param fd an open file to read from."]
    #[doc = "@param offset an index within the file at which to start reading"]
    #[doc = "@param length how much data to read, or -1 to read as much as possible."]
    #[doc = "(-1 requires that 'fd' support fstat.)"]
    #[doc = "@param flags any number of the EVBUF_FS_* flags"]
    #[doc = "@return a new evbuffer_file_segment, or NULL on failure."]
    pub fn evbuffer_file_segment_new(
        fd: ::std::os::raw::c_int,
        offset: i64,
        length: i64,
        flags: ::std::os::raw::c_uint,
    ) -> *mut evbuffer_file_segment;
}
extern "C" {
    #[doc = "Free an evbuffer_file_segment"]
    #[doc = ""]
    #[doc = "It is safe to call this function even if the segment has been added to"]
    #[doc = "one or more evbuffers.  The evbuffer_file_segment will not be freed"]
    #[doc = "until no more references to it exist."]
    pub fn evbuffer_file_segment_free(seg: *mut evbuffer_file_segment);
}
extern "C" {
    #[doc = "Add cleanup callback and argument for the callback to an"]
    #[doc = "evbuffer_file_segment."]
    #[doc = ""]
    #[doc = "The cleanup callback will be invoked when no more references to the"]
    #[doc = "evbuffer_file_segment exist."]
    pub fn evbuffer_file_segment_add_cleanup_cb(
        seg: *mut evbuffer_file_segment,
        cb: evbuffer_file_segment_cleanup_cb,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Insert some or all of an evbuffer_file_segment at the end of an evbuffer"]
    #[doc = ""]
    #[doc = "Note that the offset and length parameters of this function have a"]
    #[doc = "different meaning from those provided to evbuffer_file_segment_new: When"]
    #[doc = "you create the segment, the offset is the offset _within the file_, and"]
    #[doc = "the length is the length _of the segment_, whereas when you add a"]
    #[doc = "segment to an evbuffer, the offset is _within the segment_ and the"]
    #[doc = "length is the length of the _part of the segment you want to use."]
    #[doc = ""]
    #[doc = "In other words, if you have a 10 KiB file, and you create an"]
    #[doc = "evbuffer_file_segment for it with offset 20 and length 1000, it will"]
    #[doc = "refer to bytes 20..1019 inclusive.  If you then pass this segment to"]
    #[doc = "evbuffer_add_file_segment and specify an offset of 20 and a length of"]
    #[doc = "50, you will be adding bytes 40..99 inclusive."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer to append to"]
    #[doc = "@param seg the segment to add"]
    #[doc = "@param offset the offset within the segment to start from"]
    #[doc = "@param length the amount of data to add, or -1 to add it all."]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evbuffer_add_file_segment(
        buf: *mut evbuffer,
        seg: *mut evbuffer_file_segment,
        offset: i64,
        length: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Append a formatted string to the end of an evbuffer."]
    #[doc = ""]
    #[doc = "The string is formated as printf."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer that will be appended to"]
    #[doc = "@param fmt a format string"]
    #[doc = "@param ... arguments that will be passed to printf(3)"]
    #[doc = "@return The number of bytes added if successful, or -1 if an error occurred."]
    #[doc = ""]
    #[doc = "@see evutil_printf(), evbuffer_add_vprintf()"]
    pub fn evbuffer_add_printf(
        buf: *mut evbuffer,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Append a va_list formatted string to the end of an evbuffer."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer that will be appended to"]
    #[doc = "@param fmt a format string"]
    #[doc = "@param ap a varargs va_list argument array that will be passed to vprintf(3)"]
    #[doc = "@return The number of bytes added if successful, or -1 if an error occurred."]
    pub fn evbuffer_add_vprintf(
        buf: *mut evbuffer,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Remove a specified number of bytes data from the beginning of an evbuffer."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer to be drained"]
    #[doc = "@param len the number of bytes to drain from the beginning of the buffer"]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evbuffer_drain(buf: *mut evbuffer, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Write the contents of an evbuffer to a file descriptor."]
    #[doc = ""]
    #[doc = "The evbuffer will be drained after the bytes have been successfully written."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to be written and drained"]
    #[doc = "@param fd the file descriptor to be written to"]
    #[doc = "@return the number of bytes written, or -1 if an error occurred"]
    #[doc = "@see evbuffer_read()"]
    pub fn evbuffer_write(
        buffer: *mut evbuffer,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Write some of the contents of an evbuffer to a file descriptor."]
    #[doc = ""]
    #[doc = "The evbuffer will be drained after the bytes have been successfully written."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to be written and drained"]
    #[doc = "@param fd the file descriptor to be written to"]
    #[doc = "@param howmuch the largest allowable number of bytes to write, or -1"]
    #[doc = "to write as many bytes as we can."]
    #[doc = "@return the number of bytes written, or -1 if an error occurred"]
    #[doc = "@see evbuffer_read()"]
    pub fn evbuffer_write_atmost(
        buffer: *mut evbuffer,
        fd: ::std::os::raw::c_int,
        howmuch: ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Read from a file descriptor and store the result in an evbuffer."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to store the result"]
    #[doc = "@param fd the file descriptor to read from"]
    #[doc = "@param howmuch the number of bytes to be read"]
    #[doc = "@return the number of bytes read, or -1 if an error occurred"]
    #[doc = "@see evbuffer_write()"]
    pub fn evbuffer_read(
        buffer: *mut evbuffer,
        fd: ::std::os::raw::c_int,
        howmuch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Search for a string within an evbuffer."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to be searched"]
    #[doc = "@param what the string to be searched for"]
    #[doc = "@param len the length of the search string"]
    #[doc = "@param start NULL or a pointer to a valid struct evbuffer_ptr."]
    #[doc = "@return a struct evbuffer_ptr whose 'pos' field has the offset of the"]
    #[doc = "first occurrence of the string in the buffer after 'start'.  The 'pos'"]
    #[doc = "field of the result is -1 if the string was not found."]
    pub fn evbuffer_search(
        buffer: *mut evbuffer,
        what: *const ::std::os::raw::c_char,
        len: size_t,
        start: *const evbuffer_ptr,
    ) -> evbuffer_ptr;
}
extern "C" {
    #[doc = "Search for a string within part of an evbuffer."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to be searched"]
    #[doc = "@param what the string to be searched for"]
    #[doc = "@param len the length of the search string"]
    #[doc = "@param start NULL or a pointer to a valid struct evbuffer_ptr that"]
    #[doc = "indicates where we should start searching."]
    #[doc = "@param end NULL or a pointer to a valid struct evbuffer_ptr that"]
    #[doc = "indicates where we should stop searching."]
    #[doc = "@return a struct evbuffer_ptr whose 'pos' field has the offset of the"]
    #[doc = "first occurrence of the string in the buffer after 'start'.  The 'pos'"]
    #[doc = "field of the result is -1 if the string was not found."]
    pub fn evbuffer_search_range(
        buffer: *mut evbuffer,
        what: *const ::std::os::raw::c_char,
        len: size_t,
        start: *const evbuffer_ptr,
        end: *const evbuffer_ptr,
    ) -> evbuffer_ptr;
}
#[doc = " Sets the pointer to the position; can be called on with an"]
#[doc = "uninitialized evbuffer_ptr."]
pub const evbuffer_ptr_how_EVBUFFER_PTR_SET: evbuffer_ptr_how = 0;
#[doc = " Advances the pointer by adding to the current position."]
pub const evbuffer_ptr_how_EVBUFFER_PTR_ADD: evbuffer_ptr_how = 1;
#[doc = "Defines how to adjust an evbuffer_ptr by evbuffer_ptr_set()"]
#[doc = ""]
#[doc = "@see evbuffer_ptr_set()"]
pub type evbuffer_ptr_how = u32;
extern "C" {
    #[doc = "Sets the search pointer in the buffer to position."]
    #[doc = ""]
    #[doc = "There are two ways to use this function: you can call"]
    #[doc = "evbuffer_ptr_set(buf, &pos, N, EVBUFFER_PTR_SET)"]
    #[doc = "to move 'pos' to a position 'N' bytes after the start of the buffer, or"]
    #[doc = "evbuffer_ptr_set(buf, &pos, N, EVBUFFER_PTR_ADD)"]
    #[doc = "to move 'pos' forward by 'N' bytes."]
    #[doc = ""]
    #[doc = "If evbuffer_ptr is not initialized, this function can only be called"]
    #[doc = "with EVBUFFER_PTR_SET."]
    #[doc = ""]
    #[doc = "An evbuffer_ptr can represent any position from the start of the buffer to"]
    #[doc = "a position immediately after the end of the buffer."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to be search"]
    #[doc = "@param ptr a pointer to a struct evbuffer_ptr"]
    #[doc = "@param position the position at which to start the next search"]
    #[doc = "@param how determines how the pointer should be manipulated."]
    #[doc = "@returns 0 on success or -1 otherwise"]
    pub fn evbuffer_ptr_set(
        buffer: *mut evbuffer,
        ptr: *mut evbuffer_ptr,
        position: size_t,
        how: evbuffer_ptr_how,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Search for an end-of-line string within an evbuffer."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to be searched"]
    #[doc = "@param start NULL or a pointer to a valid struct evbuffer_ptr to start"]
    #[doc = "searching at."]
    #[doc = "@param eol_len_out If non-NULL, the pointed-to value will be set to"]
    #[doc = "the length of the end-of-line string."]
    #[doc = "@param eol_style The kind of EOL to look for; see evbuffer_readln() for"]
    #[doc = "more information"]
    #[doc = "@return a struct evbuffer_ptr whose 'pos' field has the offset of the"]
    #[doc = "first occurrence EOL in the buffer after 'start'.  The 'pos'"]
    #[doc = "field of the result is -1 if the string was not found."]
    pub fn evbuffer_search_eol(
        buffer: *mut evbuffer,
        start: *mut evbuffer_ptr,
        eol_len_out: *mut size_t,
        eol_style: evbuffer_eol_style,
    ) -> evbuffer_ptr;
}
extern "C" {
    #[doc = " Function to peek at data inside an evbuffer without removing it or"]
    #[doc = "copying it out."]
    #[doc = ""]
    #[doc = "Pointers to the data are returned by filling the 'vec_out' array"]
    #[doc = "with pointers to one or more extents of data inside the buffer."]
    #[doc = ""]
    #[doc = "The total data in the extents that you get back may be more than"]
    #[doc = "you requested (if there is more data last extent than you asked"]
    #[doc = "for), or less (if you do not provide enough evbuffer_iovecs, or if"]
    #[doc = "the buffer does not have as much data as you asked to see)."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to peek into,"]
    #[doc = "@param len the number of bytes to try to peek.  If len is negative, we"]
    #[doc = "will try to fill as much of vec_out as we can.  If len is negative"]
    #[doc = "and vec_out is not provided, we return the number of evbuffer_iovecs"]
    #[doc = "that would be needed to get all the data in the buffer."]
    #[doc = "@param start_at an evbuffer_ptr indicating the point at which we"]
    #[doc = "should start looking for data.  NULL means, \"At the start of the"]
    #[doc = "buffer.\""]
    #[doc = "@param vec_out an array of evbuffer_iovec"]
    #[doc = "@param n_vec the length of vec_out.  If 0, we only count how many"]
    #[doc = "extents would be necessary to point to the requested amount of"]
    #[doc = "data."]
    #[doc = "@return The number of extents needed.  This may be less than n_vec"]
    #[doc = "if we didn't need all the evbuffer_iovecs we were given, or more"]
    #[doc = "than n_vec if we would need more to return all the data that was"]
    #[doc = "requested."]
    pub fn evbuffer_peek(
        buffer: *mut evbuffer,
        len: ssize_t,
        start_at: *mut evbuffer_ptr,
        vec_out: *mut iovec,
        n_vec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Structure passed to an evbuffer_cb_func evbuffer callback"]
#[doc = ""]
#[doc = "@see evbuffer_cb_func, evbuffer_add_cb()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_cb_info {
    #[doc = " The number of bytes in this evbuffer when callbacks were last"]
    #[doc = " invoked."]
    pub orig_size: size_t,
    #[doc = " The number of bytes added since callbacks were last invoked."]
    pub n_added: size_t,
    #[doc = " The number of bytes removed since callbacks were last invoked."]
    pub n_deleted: size_t,
}
#[test]
fn bindgen_test_layout_evbuffer_cb_info() {
    assert_eq!(
        ::std::mem::size_of::<evbuffer_cb_info>(),
        24usize,
        concat!("Size of: ", stringify!(evbuffer_cb_info))
    );
    assert_eq!(
        ::std::mem::align_of::<evbuffer_cb_info>(),
        8usize,
        concat!("Alignment of ", stringify!(evbuffer_cb_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evbuffer_cb_info>())).orig_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_cb_info),
            "::",
            stringify!(orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evbuffer_cb_info>())).n_added as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_cb_info),
            "::",
            stringify!(n_added)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evbuffer_cb_info>())).n_deleted as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_cb_info),
            "::",
            stringify!(n_deleted)
        )
    );
}
#[doc = " Type definition for a callback that is invoked whenever data is added or"]
#[doc = "removed from an evbuffer."]
#[doc = ""]
#[doc = "An evbuffer may have one or more callbacks set at a time.  The order"]
#[doc = "in which they are executed is undefined."]
#[doc = ""]
#[doc = "A callback function may add more callbacks, or remove itself from the"]
#[doc = "list of callbacks, or add or remove data from the buffer.  It may not"]
#[doc = "remove another callback from the list."]
#[doc = ""]
#[doc = "If a callback adds or removes data from the buffer or from another"]
#[doc = "buffer, this can cause a recursive invocation of your callback or"]
#[doc = "other callbacks.  If you ask for an infinite loop, you might just get"]
#[doc = "one: watch out!"]
#[doc = ""]
#[doc = "@param buffer the buffer whose size has changed"]
#[doc = "@param info a structure describing how the buffer changed."]
#[doc = "@param arg a pointer to user data"]
pub type evbuffer_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut evbuffer,
        info: *const evbuffer_cb_info,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_cb_entry {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Add a new callback to an evbuffer."]
    #[doc = ""]
    #[doc = "Subsequent calls to evbuffer_add_cb() add new callbacks.  To remove this"]
    #[doc = "callback, call evbuffer_remove_cb or evbuffer_remove_cb_entry."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to be monitored"]
    #[doc = "@param cb the callback function to invoke when the evbuffer is modified,"]
    #[doc = "or NULL to remove all callbacks."]
    #[doc = "@param cbarg an argument to be provided to the callback function"]
    #[doc = "@return a handle to the callback on success, or NULL on failure."]
    pub fn evbuffer_add_cb(
        buffer: *mut evbuffer,
        cb: evbuffer_cb_func,
        cbarg: *mut ::std::os::raw::c_void,
    ) -> *mut evbuffer_cb_entry;
}
extern "C" {
    #[doc = " Remove a callback from an evbuffer, given a handle returned from"]
    #[doc = "evbuffer_add_cb."]
    #[doc = ""]
    #[doc = "Calling this function invalidates the handle."]
    #[doc = ""]
    #[doc = "@return 0 if a callback was removed, or -1 if no matching callback was"]
    #[doc = "found."]
    pub fn evbuffer_remove_cb_entry(
        buffer: *mut evbuffer,
        ent: *mut evbuffer_cb_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a callback from an evbuffer, given the function and argument"]
    #[doc = "used to add it."]
    #[doc = ""]
    #[doc = "@return 0 if a callback was removed, or -1 if no matching callback was"]
    #[doc = "found."]
    pub fn evbuffer_remove_cb(
        buffer: *mut evbuffer,
        cb: evbuffer_cb_func,
        cbarg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the flags that are set for a callback on a buffer by adding more."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer that the callback is watching."]
    #[doc = "@param cb the callback whose status we want to change."]
    #[doc = "@param flags EVBUFFER_CB_ENABLED to re-enable the callback."]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evbuffer_cb_set_flags(
        buffer: *mut evbuffer,
        cb: *mut evbuffer_cb_entry,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the flags that are set for a callback on a buffer by removing some"]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer that the callback is watching."]
    #[doc = "@param cb the callback whose status we want to change."]
    #[doc = "@param flags EVBUFFER_CB_ENABLED to disable the callback."]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evbuffer_cb_clear_flags(
        buffer: *mut evbuffer,
        cb: *mut evbuffer_cb_entry,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Makes the data at the beginning of an evbuffer contiguous."]
    #[doc = ""]
    #[doc = "@param buf the evbuffer to make contiguous"]
    #[doc = "@param size the number of bytes to make contiguous, or -1 to make the"]
    #[doc = "entire buffer contiguous."]
    #[doc = "@return a pointer to the contiguous memory array, or NULL if param size"]
    #[doc = "requested more data than is present in the buffer."]
    pub fn evbuffer_pullup(buf: *mut evbuffer, size: ssize_t) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = "Prepends data to the beginning of the evbuffer"]
    #[doc = ""]
    #[doc = "@param buf the evbuffer to which to prepend data"]
    #[doc = "@param data a pointer to the memory to prepend"]
    #[doc = "@param size the number of bytes to prepend"]
    #[doc = "@return 0 if successful, or -1 otherwise"]
    pub fn evbuffer_prepend(
        buf: *mut evbuffer,
        data: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Prepends all data from the src evbuffer to the beginning of the dst"]
    #[doc = "evbuffer."]
    #[doc = ""]
    #[doc = "@param dst the evbuffer to which to prepend data"]
    #[doc = "@param src the evbuffer to prepend; it will be emptied as a result"]
    #[doc = "@return 0 if successful, or -1 otherwise"]
    pub fn evbuffer_prepend_buffer(dst: *mut evbuffer, src: *mut evbuffer)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Prevent calls that modify an evbuffer from succeeding. A buffer may"]
    #[doc = "frozen at the front, at the back, or at both the front and the back."]
    #[doc = ""]
    #[doc = "If the front of a buffer is frozen, operations that drain data from"]
    #[doc = "the front of the buffer, or that prepend data to the buffer, will"]
    #[doc = "fail until it is unfrozen.   If the back a buffer is frozen, operations"]
    #[doc = "that append data from the buffer will fail until it is unfrozen."]
    #[doc = ""]
    #[doc = "@param buf The buffer to freeze"]
    #[doc = "@param at_front If true, we freeze the front of the buffer.  If false,"]
    #[doc = "we freeze the back."]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evbuffer_freeze(
        buf: *mut evbuffer,
        at_front: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Re-enable calls that modify an evbuffer."]
    #[doc = ""]
    #[doc = "@param buf The buffer to un-freeze"]
    #[doc = "@param at_front If true, we unfreeze the front of the buffer.  If false,"]
    #[doc = "we unfreeze the back."]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evbuffer_unfreeze(
        buf: *mut evbuffer,
        at_front: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Force all the callbacks on an evbuffer to be run, not immediately after"]
    #[doc = "the evbuffer is altered, but instead from inside the event loop."]
    #[doc = ""]
    #[doc = "This can be used to serialize all the callbacks to a single thread"]
    #[doc = "of execution."]
    pub fn evbuffer_defer_callbacks(
        buffer: *mut evbuffer,
        base: *mut event_base,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Append data from 1 or more iovec's to an evbuffer"]
    #[doc = ""]
    #[doc = "Calculates the number of bytes needed for an iovec structure and guarantees"]
    #[doc = "all data will fit into a single chain. Can be used in lieu of functionality"]
    #[doc = "which calls evbuffer_add() constantly before being used to increase"]
    #[doc = "performance."]
    #[doc = ""]
    #[doc = "@param buffer the destination buffer"]
    #[doc = "@param vec the source iovec"]
    #[doc = "@param n_vec the number of iovec structures."]
    #[doc = "@return the number of bytes successfully written to the output buffer."]
    pub fn evbuffer_add_iovec(
        buffer: *mut evbuffer,
        vec: *mut iovec,
        n_vec: ::std::os::raw::c_int,
    ) -> size_t;
}
extern "C" {
    #[doc = "Obsolete alias for evbuffer_readln(buffer, NULL, EVBUFFER_EOL_ANY)."]
    #[doc = ""]
    #[doc = "@deprecated This function is deprecated because its behavior is not correct"]
    #[doc = "for almost any protocol, and also because it's wholly subsumed by"]
    #[doc = "evbuffer_readln()."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to read from"]
    #[doc = "@return pointer to a single line, or NULL if an error occurred"]
    pub fn evbuffer_readline(buffer: *mut evbuffer) -> *mut ::std::os::raw::c_char;
}
#[doc = " Type definition for a callback that is invoked whenever data is added or"]
#[doc = "removed from an evbuffer."]
#[doc = ""]
#[doc = "An evbuffer may have one or more callbacks set at a time.  The order"]
#[doc = "in which they are executed is undefined."]
#[doc = ""]
#[doc = "A callback function may add more callbacks, or remove itself from the"]
#[doc = "list of callbacks, or add or remove data from the buffer.  It may not"]
#[doc = "remove another callback from the list."]
#[doc = ""]
#[doc = "If a callback adds or removes data from the buffer or from another"]
#[doc = "buffer, this can cause a recursive invocation of your callback or"]
#[doc = "other callbacks.  If you ask for an infinite loop, you might just get"]
#[doc = "one: watch out!"]
#[doc = ""]
#[doc = "@param buffer the buffer whose size has changed"]
#[doc = "@param old_len the previous length of the buffer"]
#[doc = "@param new_len the current length of the buffer"]
#[doc = "@param arg a pointer to user data"]
pub type evbuffer_cb = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut evbuffer,
        old_len: size_t,
        new_len: size_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Replace all callbacks on an evbuffer with a single new callback, or"]
    #[doc = "remove them."]
    #[doc = ""]
    #[doc = "Subsequent calls to evbuffer_setcb() replace callbacks set by previous"]
    #[doc = "calls.  Setting the callback to NULL removes any previously set callback."]
    #[doc = ""]
    #[doc = "@deprecated This function is deprecated because it clears all previous"]
    #[doc = "callbacks set on the evbuffer, which can cause confusing behavior if"]
    #[doc = "multiple parts of the code all want to add their own callbacks on a"]
    #[doc = "buffer.  Instead, use evbuffer_add(), evbuffer_del(), and"]
    #[doc = "evbuffer_setflags() to manage your own evbuffer callbacks without"]
    #[doc = "interfering with callbacks set by others."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to be monitored"]
    #[doc = "@param cb the callback function to invoke when the evbuffer is modified,"]
    #[doc = "or NULL to remove all callbacks."]
    #[doc = "@param cbarg an argument to be provided to the callback function"]
    #[doc = "@return 0 if successful, or -1 on error"]
    pub fn evbuffer_setcb(
        buffer: *mut evbuffer,
        cb: evbuffer_cb,
        cbarg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Find a string within an evbuffer."]
    #[doc = ""]
    #[doc = "@param buffer the evbuffer to be searched"]
    #[doc = "@param what the string to be searched for"]
    #[doc = "@param len the length of the search string"]
    #[doc = "@return a pointer to the beginning of the search string, or NULL if the search failed."]
    pub fn evbuffer_find(
        buffer: *mut evbuffer,
        what: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> *mut ::std::os::raw::c_uchar;
}
#[doc = "A read or write callback for a bufferevent."]
#[doc = ""]
#[doc = "The read callback is triggered when new data arrives in the input"]
#[doc = "buffer and the amount of readable data exceed the low watermark"]
#[doc = "which is 0 by default."]
#[doc = ""]
#[doc = "The write callback is triggered if the write buffer has been"]
#[doc = "exhausted or fell below its low watermark."]
#[doc = ""]
#[doc = "@param bev the bufferevent that triggered the callback"]
#[doc = "@param ctx the user-specified context for this bufferevent"]
pub type bufferevent_data_cb = ::std::option::Option<
    unsafe extern "C" fn(bev: *mut bufferevent, ctx: *mut ::std::os::raw::c_void),
>;
#[doc = "An event/error callback for a bufferevent."]
#[doc = ""]
#[doc = "The event callback is triggered if either an EOF condition or another"]
#[doc = "unrecoverable error was encountered."]
#[doc = ""]
#[doc = "For bufferevents with deferred callbacks, this is a bitwise OR of all errors"]
#[doc = "that have happened on the bufferevent since the last callback invocation."]
#[doc = ""]
#[doc = "@param bev the bufferevent for which the error condition was reached"]
#[doc = "@param what a conjunction of flags: BEV_EVENT_READING or BEV_EVENT_WRITING"]
#[doc = "to indicate if the error was encountered on the read or write path,"]
#[doc = "and one of the following flags: BEV_EVENT_EOF, BEV_EVENT_ERROR,"]
#[doc = "BEV_EVENT_TIMEOUT, BEV_EVENT_CONNECTED."]
#[doc = ""]
#[doc = "@param ctx the user-specified context for this bufferevent"]
pub type bufferevent_event_cb = ::std::option::Option<
    unsafe extern "C" fn(
        bev: *mut bufferevent,
        what: ::std::os::raw::c_short,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " If set, we close the underlying file"]
#[doc = " descriptor/bufferevent/whatever when this bufferevent is freed."]
pub const bufferevent_options_BEV_OPT_CLOSE_ON_FREE: bufferevent_options = 1;
#[doc = " If set, and threading is enabled, operations on this bufferevent"]
#[doc = " are protected by a lock"]
pub const bufferevent_options_BEV_OPT_THREADSAFE: bufferevent_options = 2;
#[doc = " If set, callbacks are run deferred in the event loop."]
pub const bufferevent_options_BEV_OPT_DEFER_CALLBACKS: bufferevent_options = 4;
#[doc = " If set, callbacks are executed without locks being held on the"]
#[doc = " bufferevent.  This option currently requires that"]
#[doc = " BEV_OPT_DEFER_CALLBACKS also be set; a future version of Libevent"]
#[doc = " might remove the requirement."]
pub const bufferevent_options_BEV_OPT_UNLOCK_CALLBACKS: bufferevent_options = 8;
#[doc = " Options that can be specified when creating a bufferevent"]
pub type bufferevent_options = u32;
extern "C" {
    #[doc = "Create a new socket bufferevent over an existing socket."]
    #[doc = ""]
    #[doc = "@param base the event base to associate with the new bufferevent."]
    #[doc = "@param fd the file descriptor from which data is read and written to."]
    #[doc = "This file descriptor is not allowed to be a pipe(2)."]
    #[doc = "It is safe to set the fd to -1, so long as you later"]
    #[doc = "set it with bufferevent_setfd or bufferevent_socket_connect()."]
    #[doc = "@param options Zero or more BEV_OPT_* flags"]
    #[doc = "@return a pointer to a newly allocated bufferevent struct, or NULL if an"]
    #[doc = "error occurred"]
    #[doc = "@see bufferevent_free()"]
    pub fn bufferevent_socket_new(
        base: *mut event_base,
        fd: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
    ) -> *mut bufferevent;
}
extern "C" {
    #[doc = "Launch a connect() attempt with a socket-based bufferevent."]
    #[doc = ""]
    #[doc = "When the connect succeeds, the eventcb will be invoked with"]
    #[doc = "BEV_EVENT_CONNECTED set."]
    #[doc = ""]
    #[doc = "If the bufferevent does not already have a socket set, we allocate a new"]
    #[doc = "socket here and make it nonblocking before we begin."]
    #[doc = ""]
    #[doc = "If no address is provided, we assume that the socket is already connecting,"]
    #[doc = "and configure the bufferevent so that a BEV_EVENT_CONNECTED event will be"]
    #[doc = "yielded when it is done connecting."]
    #[doc = ""]
    #[doc = "@param bufev an existing bufferevent allocated with"]
    #[doc = "bufferevent_socket_new()."]
    #[doc = "@param addr the address we should connect to"]
    #[doc = "@param socklen The length of the address"]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn bufferevent_socket_connect(
        arg1: *mut bufferevent,
        arg2: *const sockaddr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evdns_base {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Resolve the hostname 'hostname' and connect to it as with"]
    #[doc = "bufferevent_socket_connect()."]
    #[doc = ""]
    #[doc = "@param bufev An existing bufferevent allocated with bufferevent_socket_new()"]
    #[doc = "@param evdns_base Optionally, an evdns_base to use for resolving hostnames"]
    #[doc = "asynchronously. May be set to NULL for a blocking resolve."]
    #[doc = "@param family A preferred address family to resolve addresses to, or"]
    #[doc = "AF_UNSPEC for no preference.  Only AF_INET, AF_INET6, and AF_UNSPEC are"]
    #[doc = "supported."]
    #[doc = "@param hostname The hostname to resolve; see below for notes on recognized"]
    #[doc = "formats"]
    #[doc = "@param port The port to connect to on the resolved address."]
    #[doc = "@return 0 if successful, -1 on failure."]
    #[doc = ""]
    #[doc = "Recognized hostname formats are:"]
    #[doc = ""]
    #[doc = "www.example.com\t(hostname)"]
    #[doc = "1.2.3.4\t\t(ipv4address)"]
    #[doc = "::1\t\t(ipv6address)"]
    #[doc = "[::1]\t\t([ipv6address])"]
    #[doc = ""]
    #[doc = "Performance note: If you do not provide an evdns_base, this function"]
    #[doc = "may block while it waits for a DNS response.\t This is probably not"]
    #[doc = "what you want."]
    pub fn bufferevent_socket_connect_hostname(
        arg1: *mut bufferevent,
        arg2: *mut evdns_base,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the error code for the last failed DNS lookup attempt made by"]
    #[doc = "bufferevent_socket_connect_hostname()."]
    #[doc = ""]
    #[doc = "@param bev The bufferevent object."]
    #[doc = "@return DNS error code."]
    #[doc = "@see evutil_gai_strerror()"]
    pub fn bufferevent_socket_get_dns_error(bev: *mut bufferevent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Assign a bufferevent to a specific event_base."]
    #[doc = ""]
    #[doc = "NOTE that only socket bufferevents support this function."]
    #[doc = ""]
    #[doc = "@param base an event_base returned by event_init()"]
    #[doc = "@param bufev a bufferevent struct returned by bufferevent_new()"]
    #[doc = "or bufferevent_socket_new()"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see bufferevent_new()"]
    pub fn bufferevent_base_set(
        base: *mut event_base,
        bufev: *mut bufferevent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the event_base used by a bufferevent"]
    pub fn bufferevent_get_base(bev: *mut bufferevent) -> *mut event_base;
}
extern "C" {
    #[doc = "Assign a priority to a bufferevent."]
    #[doc = ""]
    #[doc = "Only supported for socket bufferevents."]
    #[doc = ""]
    #[doc = "@param bufev a bufferevent struct"]
    #[doc = "@param pri the priority to be assigned"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    pub fn bufferevent_priority_set(
        bufev: *mut bufferevent,
        pri: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the priority of a bufferevent."]
    #[doc = ""]
    #[doc = "Only supported for socket bufferevents"]
    pub fn bufferevent_get_priority(bufev: *const bufferevent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Deallocate the storage associated with a bufferevent structure."]
    #[doc = ""]
    #[doc = "If there is pending data to write on the bufferevent, it probably won't be"]
    #[doc = "flushed before the bufferevent is freed."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent structure to be freed."]
    pub fn bufferevent_free(bufev: *mut bufferevent);
}
extern "C" {
    #[doc = "Changes the callbacks for a bufferevent."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent object for which to change callbacks"]
    #[doc = "@param readcb callback to invoke when there is data to be read, or NULL if"]
    #[doc = "no callback is desired"]
    #[doc = "@param writecb callback to invoke when the file descriptor is ready for"]
    #[doc = "writing, or NULL if no callback is desired"]
    #[doc = "@param eventcb callback to invoke when there is an event on the file"]
    #[doc = "descriptor"]
    #[doc = "@param cbarg an argument that will be supplied to each of the callbacks"]
    #[doc = "(readcb, writecb, and errorcb)"]
    #[doc = "@see bufferevent_new()"]
    pub fn bufferevent_setcb(
        bufev: *mut bufferevent,
        readcb: bufferevent_data_cb,
        writecb: bufferevent_data_cb,
        eventcb: bufferevent_event_cb,
        cbarg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Retrieves the callbacks for a bufferevent."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to examine."]
    #[doc = "@param readcb_ptr if readcb_ptr is nonnull, *readcb_ptr is set to the current"]
    #[doc = "read callback for the bufferevent."]
    #[doc = "@param writecb_ptr if writecb_ptr is nonnull, *writecb_ptr is set to the"]
    #[doc = "current write callback for the bufferevent."]
    #[doc = "@param eventcb_ptr if eventcb_ptr is nonnull, *eventcb_ptr is set to the"]
    #[doc = "current event callback for the bufferevent."]
    #[doc = "@param cbarg_ptr if cbarg_ptr is nonnull, *cbarg_ptr is set to the current"]
    #[doc = "callback argument for the bufferevent."]
    #[doc = "@see buffervent_setcb()"]
    pub fn bufferevent_getcb(
        bufev: *mut bufferevent,
        readcb_ptr: *mut bufferevent_data_cb,
        writecb_ptr: *mut bufferevent_data_cb,
        eventcb_ptr: *mut bufferevent_event_cb,
        cbarg_ptr: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Changes the file descriptor on which the bufferevent operates."]
    #[doc = "Not supported for all bufferevent types."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent object for which to change the file descriptor"]
    #[doc = "@param fd the file descriptor to operate on"]
    pub fn bufferevent_setfd(
        bufev: *mut bufferevent,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the file descriptor associated with a bufferevent, or -1 if"]
    #[doc = "no file descriptor is associated with the bufferevent."]
    pub fn bufferevent_getfd(bufev: *mut bufferevent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the underlying bufferevent associated with a bufferevent (if"]
    #[doc = "the bufferevent is a wrapper), or NULL if there is no underlying bufferevent."]
    pub fn bufferevent_get_underlying(bufev: *mut bufferevent) -> *mut bufferevent;
}
extern "C" {
    #[doc = "Write data to a bufferevent buffer."]
    #[doc = ""]
    #[doc = "The bufferevent_write() function can be used to write data to the file"]
    #[doc = "descriptor.  The data is appended to the output buffer and written to the"]
    #[doc = "descriptor automatically as it becomes available for writing."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be written to"]
    #[doc = "@param data a pointer to the data to be written"]
    #[doc = "@param size the length of the data, in bytes"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see bufferevent_write_buffer()"]
    pub fn bufferevent_write(
        bufev: *mut bufferevent,
        data: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Write data from an evbuffer to a bufferevent buffer.\tThe evbuffer is"]
    #[doc = "being drained as a result."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be written to"]
    #[doc = "@param buf the evbuffer to be written"]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see bufferevent_write()"]
    pub fn bufferevent_write_buffer(
        bufev: *mut bufferevent,
        buf: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Read data from a bufferevent buffer."]
    #[doc = ""]
    #[doc = "The bufferevent_read() function is used to read data from the input buffer."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be read from"]
    #[doc = "@param data pointer to a buffer that will store the data"]
    #[doc = "@param size the size of the data buffer, in bytes"]
    #[doc = "@return the amount of data read, in bytes."]
    pub fn bufferevent_read(
        bufev: *mut bufferevent,
        data: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = "Read data from a bufferevent buffer into an evbuffer.\t This avoids"]
    #[doc = "memory copies."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be read from"]
    #[doc = "@param buf the evbuffer to which to add data"]
    #[doc = "@return 0 if successful, or -1 if an error occurred."]
    pub fn bufferevent_read_buffer(
        bufev: *mut bufferevent,
        buf: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the input buffer."]
    #[doc = ""]
    #[doc = "The user MUST NOT set the callback on this buffer."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent from which to get the evbuffer"]
    #[doc = "@return the evbuffer object for the input buffer"]
    pub fn bufferevent_get_input(bufev: *mut bufferevent) -> *mut evbuffer;
}
extern "C" {
    #[doc = "Returns the output buffer."]
    #[doc = ""]
    #[doc = "The user MUST NOT set the callback on this buffer."]
    #[doc = ""]
    #[doc = "When filters are being used, the filters need to be manually"]
    #[doc = "triggered if the output buffer was manipulated."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent from which to get the evbuffer"]
    #[doc = "@return the evbuffer object for the output buffer"]
    pub fn bufferevent_get_output(bufev: *mut bufferevent) -> *mut evbuffer;
}
extern "C" {
    #[doc = "Enable a bufferevent."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be enabled"]
    #[doc = "@param event any combination of EV_READ | EV_WRITE."]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see bufferevent_disable()"]
    pub fn bufferevent_enable(
        bufev: *mut bufferevent,
        event: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Disable a bufferevent."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be disabled"]
    #[doc = "@param event any combination of EV_READ | EV_WRITE."]
    #[doc = "@return 0 if successful, or -1 if an error occurred"]
    #[doc = "@see bufferevent_enable()"]
    pub fn bufferevent_disable(
        bufev: *mut bufferevent,
        event: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the events that are enabled on a given bufferevent."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to inspect"]
    #[doc = "@return A combination of EV_READ | EV_WRITE"]
    pub fn bufferevent_get_enabled(bufev: *mut bufferevent) -> ::std::os::raw::c_short;
}
extern "C" {
    #[doc = "Set the read and write timeout for a bufferevent."]
    #[doc = ""]
    #[doc = "A bufferevent's timeout will fire the first time that the indicated"]
    #[doc = "amount of time has elapsed since a successful read or write operation,"]
    #[doc = "during which the bufferevent was trying to read or write."]
    #[doc = ""]
    #[doc = "(In other words, if reading or writing is disabled, or if the"]
    #[doc = "bufferevent's read or write operation has been suspended because"]
    #[doc = "there's no data to write, or not enough bandwidth, or so on, the"]
    #[doc = "timeout isn't active.  The timeout only becomes active when we we're"]
    #[doc = "willing to actually read or write.)"]
    #[doc = ""]
    #[doc = "Calling bufferevent_enable or setting a timeout for a bufferevent"]
    #[doc = "whose timeout is already pending resets its timeout."]
    #[doc = ""]
    #[doc = "If the timeout elapses, the corresponding operation (EV_READ or"]
    #[doc = "EV_WRITE) becomes disabled until you re-enable it again.  The"]
    #[doc = "bufferevent's event callback is called with the"]
    #[doc = "BEV_EVENT_TIMEOUT|BEV_EVENT_READING or"]
    #[doc = "BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be modified"]
    #[doc = "@param timeout_read the read timeout, or NULL"]
    #[doc = "@param timeout_write the write timeout, or NULL"]
    pub fn bufferevent_set_timeouts(
        bufev: *mut bufferevent,
        timeout_read: *const timeval,
        timeout_write: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Sets the watermarks for read and write events."]
    #[doc = ""]
    #[doc = "On input, a bufferevent does not invoke the user read callback unless"]
    #[doc = "there is at least low watermark data in the buffer.\tIf the read buffer"]
    #[doc = "is beyond the high watermark, the bufferevent stops reading from the network."]
    #[doc = "But be aware that bufferevent input/read buffer can overrun high watermark"]
    #[doc = "limit (typical example is openssl bufferevent), so you should not relay in"]
    #[doc = "this."]
    #[doc = ""]
    #[doc = "On output, the user write callback is invoked whenever the buffered data"]
    #[doc = "falls below the low watermark.  Filters that write to this bufev will try"]
    #[doc = "not to write more bytes to this buffer than the high watermark would allow,"]
    #[doc = "except when flushing."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be modified"]
    #[doc = "@param events EV_READ, EV_WRITE or both"]
    #[doc = "@param lowmark the lower watermark to set"]
    #[doc = "@param highmark the high watermark to set"]
    pub fn bufferevent_setwatermark(
        bufev: *mut bufferevent,
        events: ::std::os::raw::c_short,
        lowmark: size_t,
        highmark: size_t,
    );
}
extern "C" {
    #[doc = "Retrieves the watermarks for read or write events."]
    #[doc = "Returns non-zero if events contains not only EV_READ or EV_WRITE."]
    #[doc = "Returns zero if events equal EV_READ or EV_WRITE"]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be examined"]
    #[doc = "@param events EV_READ or EV_WRITE"]
    #[doc = "@param lowmark receives the lower watermark if not NULL"]
    #[doc = "@param highmark receives the high watermark if not NULL"]
    pub fn bufferevent_getwatermark(
        bufev: *mut bufferevent,
        events: ::std::os::raw::c_short,
        lowmark: *mut size_t,
        highmark: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Acquire the lock on a bufferevent.  Has no effect if locking was not"]
    #[doc = "enabled with BEV_OPT_THREADSAFE."]
    pub fn bufferevent_lock(bufev: *mut bufferevent);
}
extern "C" {
    #[doc = "Release the lock on a bufferevent.  Has no effect if locking was not"]
    #[doc = "enabled with BEV_OPT_THREADSAFE."]
    pub fn bufferevent_unlock(bufev: *mut bufferevent);
}
extern "C" {
    #[doc = " Public interface to manually increase the reference count of a bufferevent"]
    #[doc = " this is useful in situations where a user may reference the bufferevent"]
    #[doc = " somewhere else (unknown to libevent)"]
    #[doc = ""]
    #[doc = " @param bufev the bufferevent to increase the refcount on"]
    #[doc = ""]
    pub fn bufferevent_incref(bufev: *mut bufferevent);
}
extern "C" {
    #[doc = " Public interface to manually decrement the reference count of a bufferevent"]
    #[doc = ""]
    #[doc = " Warning: make sure you know what you're doing. This is mainly used in"]
    #[doc = " conjunction with bufferevent_incref(). This will free up all data associated"]
    #[doc = " with a bufferevent if the reference count hits 0."]
    #[doc = ""]
    #[doc = " @param bufev the bufferevent to decrement the refcount on"]
    #[doc = ""]
    #[doc = " @return 1 if the bufferevent was freed, otherwise 0 (still referenced)"]
    pub fn bufferevent_decref(bufev: *mut bufferevent) -> ::std::os::raw::c_int;
}
#[doc = " usually set when processing data"]
pub const bufferevent_flush_mode_BEV_NORMAL: bufferevent_flush_mode = 0;
#[doc = " want to checkpoint all data sent."]
pub const bufferevent_flush_mode_BEV_FLUSH: bufferevent_flush_mode = 1;
#[doc = " encountered EOF on read or done sending data"]
pub const bufferevent_flush_mode_BEV_FINISHED: bufferevent_flush_mode = 2;
#[doc = "Flags that can be passed into filters to let them know how to"]
#[doc = "deal with the incoming data."]
pub type bufferevent_flush_mode = u32;
extern "C" {
    #[doc = "Triggers the bufferevent to produce more data if possible."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent object"]
    #[doc = "@param iotype either EV_READ or EV_WRITE or both."]
    #[doc = "@param mode either BEV_NORMAL or BEV_FLUSH or BEV_FINISHED"]
    #[doc = "@return -1 on failure, 0 if no data was produces, 1 if data was produced"]
    pub fn bufferevent_flush(
        bufev: *mut bufferevent,
        iotype: ::std::os::raw::c_short,
        mode: bufferevent_flush_mode,
    ) -> ::std::os::raw::c_int;
}
#[doc = " trigger the callback regardless of the watermarks"]
pub const bufferevent_trigger_options_BEV_TRIG_IGNORE_WATERMARKS: bufferevent_trigger_options =
    65536;
#[doc = " defer even if the callbacks are not"]
pub const bufferevent_trigger_options_BEV_TRIG_DEFER_CALLBACKS: bufferevent_trigger_options = 4;
#[doc = "Flags for bufferevent_trigger(_event) that modify when and how to trigger"]
#[doc = "the callback."]
pub type bufferevent_trigger_options = u32;
extern "C" {
    #[doc = "Triggers bufferevent data callbacks."]
    #[doc = ""]
    #[doc = "The function will honor watermarks unless options contain"]
    #[doc = "BEV_TRIG_IGNORE_WATERMARKS. If the options contain BEV_OPT_DEFER_CALLBACKS,"]
    #[doc = "the callbacks are deferred."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent object"]
    #[doc = "@param iotype either EV_READ or EV_WRITE or both."]
    #[doc = "@param options"]
    pub fn bufferevent_trigger(
        bufev: *mut bufferevent,
        iotype: ::std::os::raw::c_short,
        options: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "Triggers the bufferevent event callback."]
    #[doc = ""]
    #[doc = "If the options contain BEV_OPT_DEFER_CALLBACKS, the callbacks are deferred."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent object"]
    #[doc = "@param what the flags to pass onto the event callback"]
    #[doc = "@param options"]
    pub fn bufferevent_trigger_event(
        bufev: *mut bufferevent,
        what: ::std::os::raw::c_short,
        options: ::std::os::raw::c_int,
    );
}
#[doc = " everything is okay"]
pub const bufferevent_filter_result_BEV_OK: bufferevent_filter_result = 0;
#[doc = " the filter needs to read more data before output"]
pub const bufferevent_filter_result_BEV_NEED_MORE: bufferevent_filter_result = 1;
#[doc = " the filter encountered a critical error, no further data"]
#[doc = "can be processed."]
pub const bufferevent_filter_result_BEV_ERROR: bufferevent_filter_result = 2;
#[doc = "@name Filtering support"]
#[doc = ""]
#[doc = "@{"]
#[doc = "Values that filters can return."]
pub type bufferevent_filter_result = u32;
#[doc = " A callback function to implement a filter for a bufferevent."]
#[doc = ""]
#[doc = "@param src An evbuffer to drain data from."]
#[doc = "@param dst An evbuffer to add data to."]
#[doc = "@param limit A suggested upper bound of bytes to write to dst."]
#[doc = "The filter may ignore this value, but doing so means that"]
#[doc = "it will overflow the high-water mark associated with dst."]
#[doc = "-1 means \"no limit\"."]
#[doc = "@param mode Whether we should write data as may be convenient"]
#[doc = "(BEV_NORMAL), or flush as much data as we can (BEV_FLUSH),"]
#[doc = "or flush as much as we can, possibly including an end-of-stream"]
#[doc = "marker (BEV_FINISH)."]
#[doc = "@param ctx A user-supplied pointer."]
#[doc = ""]
#[doc = "@return BEV_OK if we wrote some data; BEV_NEED_MORE if we can't"]
#[doc = "produce any more output until we get some input; and BEV_ERROR"]
#[doc = "on an error."]
pub type bufferevent_filter_cb = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut evbuffer,
        dst: *mut evbuffer,
        dst_limit: ssize_t,
        mode: bufferevent_flush_mode,
        ctx: *mut ::std::os::raw::c_void,
    ) -> bufferevent_filter_result,
>;
extern "C" {
    #[doc = "Allocate a new filtering bufferevent on top of an existing bufferevent."]
    #[doc = ""]
    #[doc = "@param underlying the underlying bufferevent."]
    #[doc = "@param input_filter The filter to apply to data we read from the underlying"]
    #[doc = "bufferevent"]
    #[doc = "@param output_filter The filer to apply to data we write to the underlying"]
    #[doc = "bufferevent"]
    #[doc = "@param options A bitfield of bufferevent options."]
    #[doc = "@param free_context A function to use to free the filter context when"]
    #[doc = "this bufferevent is freed."]
    #[doc = "@param ctx A context pointer to pass to the filter functions."]
    pub fn bufferevent_filter_new(
        underlying: *mut bufferevent,
        input_filter: bufferevent_filter_cb,
        output_filter: bufferevent_filter_cb,
        options: ::std::os::raw::c_int,
        free_context: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut bufferevent;
}
extern "C" {
    #[doc = "Allocate a pair of linked bufferevents.  The bufferevents behave as would"]
    #[doc = "two bufferevent_sock instances connected to opposite ends of a"]
    #[doc = "socketpair(), except that no internal socketpair is allocated."]
    #[doc = ""]
    #[doc = "@param base The event base to associate with the socketpair."]
    #[doc = "@param options A set of options for this bufferevent"]
    #[doc = "@param pair A pointer to an array to hold the two new bufferevent objects."]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn bufferevent_pair_new(
        base: *mut event_base,
        options: ::std::os::raw::c_int,
        pair: *mut *mut bufferevent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Given one bufferevent returned by bufferevent_pair_new(), returns the"]
    #[doc = "other one if it still exists.  Otherwise returns NULL."]
    pub fn bufferevent_pair_get_partner(bev: *mut bufferevent) -> *mut bufferevent;
}
#[doc = "Abstract type used to configure rate-limiting on a bufferevent or a group"]
#[doc = "of bufferevents."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ev_token_bucket_cfg {
    _unused: [u8; 0],
}
#[doc = "A group of bufferevents which are configured to respect the same rate"]
#[doc = "limit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bufferevent_rate_limit_group {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Initialize and return a new object to configure the rate-limiting behavior"]
    #[doc = "of bufferevents."]
    #[doc = ""]
    #[doc = "@param read_rate The maximum number of bytes to read per tick on"]
    #[doc = "average."]
    #[doc = "@param read_burst The maximum number of bytes to read in any single tick."]
    #[doc = "@param write_rate The maximum number of bytes to write per tick on"]
    #[doc = "average."]
    #[doc = "@param write_burst The maximum number of bytes to write in any single tick."]
    #[doc = "@param tick_len The length of a single tick.\t Defaults to one second."]
    #[doc = "Any fractions of a millisecond are ignored."]
    #[doc = ""]
    #[doc = "Note that all rate-limits hare are currently best-effort: future versions"]
    #[doc = "of Libevent may implement them more tightly."]
    pub fn ev_token_bucket_cfg_new(
        read_rate: size_t,
        read_burst: size_t,
        write_rate: size_t,
        write_burst: size_t,
        tick_len: *const timeval,
    ) -> *mut ev_token_bucket_cfg;
}
extern "C" {
    #[doc = " Free all storage held in 'cfg'."]
    #[doc = ""]
    #[doc = "Note: 'cfg' is not currently reference-counted; it is not safe to free it"]
    #[doc = "until no bufferevent is using it."]
    pub fn ev_token_bucket_cfg_free(cfg: *mut ev_token_bucket_cfg);
}
extern "C" {
    #[doc = "Set the rate-limit of a the bufferevent 'bev' to the one specified in"]
    #[doc = "'cfg'.  If 'cfg' is NULL, disable any per-bufferevent rate-limiting on"]
    #[doc = "'bev'."]
    #[doc = ""]
    #[doc = "Note that only some bufferevent types currently respect rate-limiting."]
    #[doc = "They are: socket-based bufferevents (normal and IOCP-based), and SSL-based"]
    #[doc = "bufferevents."]
    #[doc = ""]
    #[doc = "Return 0 on success, -1 on failure."]
    pub fn bufferevent_set_rate_limit(
        bev: *mut bufferevent,
        cfg: *mut ev_token_bucket_cfg,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Create a new rate-limit group for bufferevents.  A rate-limit group"]
    #[doc = "constrains the maximum number of bytes sent and received, in toto,"]
    #[doc = "by all of its bufferevents."]
    #[doc = ""]
    #[doc = "@param base An event_base to run any necessary timeouts for the group."]
    #[doc = "Note that all bufferevents in the group do not necessarily need to share"]
    #[doc = "this event_base."]
    #[doc = "@param cfg The rate-limit for this group."]
    #[doc = ""]
    #[doc = "Note that all rate-limits hare are currently best-effort: future versions"]
    #[doc = "of Libevent may implement them more tightly."]
    #[doc = ""]
    #[doc = "Note also that only some bufferevent types currently respect rate-limiting."]
    #[doc = "They are: socket-based bufferevents (normal and IOCP-based), and SSL-based"]
    #[doc = "bufferevents."]
    pub fn bufferevent_rate_limit_group_new(
        base: *mut event_base,
        cfg: *const ev_token_bucket_cfg,
    ) -> *mut bufferevent_rate_limit_group;
}
extern "C" {
    #[doc = "Change the rate-limiting settings for a given rate-limiting group."]
    #[doc = ""]
    #[doc = "Return 0 on success, -1 on failure."]
    pub fn bufferevent_rate_limit_group_set_cfg(
        arg1: *mut bufferevent_rate_limit_group,
        arg2: *const ev_token_bucket_cfg,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Change the smallest quantum we're willing to allocate to any single"]
    #[doc = "bufferevent in a group for reading or writing at a time."]
    #[doc = ""]
    #[doc = "The rationale is that, because of TCP/IP protocol overheads and kernel"]
    #[doc = "behavior, if a rate-limiting group is so tight on bandwidth that you're"]
    #[doc = "only willing to send 1 byte per tick per bufferevent, you might instead"]
    #[doc = "want to batch up the reads and writes so that you send N bytes per"]
    #[doc = "1/N of the bufferevents (chosen at random) each tick, so you still wind"]
    #[doc = "up send 1 byte per tick per bufferevent on average, but you don't send"]
    #[doc = "so many tiny packets."]
    #[doc = ""]
    #[doc = "The default min-share is currently 64 bytes."]
    #[doc = ""]
    #[doc = "Returns 0 on success, -1 on failure."]
    pub fn bufferevent_rate_limit_group_set_min_share(
        arg1: *mut bufferevent_rate_limit_group,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Free a rate-limiting group.  The group must have no members when"]
    #[doc = "this function is called."]
    pub fn bufferevent_rate_limit_group_free(arg1: *mut bufferevent_rate_limit_group);
}
extern "C" {
    #[doc = "Add 'bev' to the list of bufferevents whose aggregate reading and writing"]
    #[doc = "is restricted by 'g'.  If 'g' is NULL, remove 'bev' from its current group."]
    #[doc = ""]
    #[doc = "A bufferevent may belong to no more than one rate-limit group at a time."]
    #[doc = "If 'bev' is already a member of a group, it will be removed from its old"]
    #[doc = "group before being added to 'g'."]
    #[doc = ""]
    #[doc = "Return 0 on success and -1 on failure."]
    pub fn bufferevent_add_to_rate_limit_group(
        bev: *mut bufferevent,
        g: *mut bufferevent_rate_limit_group,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove 'bev' from its current rate-limit group (if any)."]
    pub fn bufferevent_remove_from_rate_limit_group(bev: *mut bufferevent)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set the size limit for single read operation."]
    #[doc = ""]
    #[doc = "Set to 0 for a reasonable default."]
    #[doc = ""]
    #[doc = "Return 0 on success and -1 on failure."]
    pub fn bufferevent_set_max_single_read(
        bev: *mut bufferevent,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set the size limit for single write operation."]
    #[doc = ""]
    #[doc = "Set to 0 for a reasonable default."]
    #[doc = ""]
    #[doc = "Return 0 on success and -1 on failure."]
    pub fn bufferevent_set_max_single_write(
        bev: *mut bufferevent,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current size limit for single read operation."]
    pub fn bufferevent_get_max_single_read(bev: *mut bufferevent) -> ssize_t;
}
extern "C" {
    #[doc = " Get the current size limit for single write operation."]
    pub fn bufferevent_get_max_single_write(bev: *mut bufferevent) -> ssize_t;
}
extern "C" {
    #[doc = "@name Rate limit inspection"]
    #[doc = ""]
    #[doc = "Return the current read or write bucket size for a bufferevent."]
    #[doc = "If it is not configured with a per-bufferevent ratelimit, return"]
    #[doc = "EV_SSIZE_MAX.  This function does not inspect the group limit, if any."]
    #[doc = "Note that it can return a negative value if the bufferevent has been"]
    #[doc = "made to read or write more than its limit."]
    #[doc = ""]
    #[doc = "@{"]
    pub fn bufferevent_get_read_limit(bev: *mut bufferevent) -> ssize_t;
}
extern "C" {
    pub fn bufferevent_get_write_limit(bev: *mut bufferevent) -> ssize_t;
}
extern "C" {
    pub fn bufferevent_get_max_to_read(bev: *mut bufferevent) -> ssize_t;
}
extern "C" {
    pub fn bufferevent_get_max_to_write(bev: *mut bufferevent) -> ssize_t;
}
extern "C" {
    pub fn bufferevent_get_token_bucket_cfg(bev: *const bufferevent) -> *const ev_token_bucket_cfg;
}
extern "C" {
    #[doc = "@name Group Rate limit inspection"]
    #[doc = ""]
    #[doc = "Return the read or write bucket size for a bufferevent rate limit"]
    #[doc = "group.  Note that it can return a negative value if bufferevents in"]
    #[doc = "the group have been made to read or write more than their limits."]
    #[doc = ""]
    #[doc = "@{"]
    pub fn bufferevent_rate_limit_group_get_read_limit(
        arg1: *mut bufferevent_rate_limit_group,
    ) -> ssize_t;
}
extern "C" {
    pub fn bufferevent_rate_limit_group_get_write_limit(
        arg1: *mut bufferevent_rate_limit_group,
    ) -> ssize_t;
}
extern "C" {
    #[doc = "@name Rate limit manipulation"]
    #[doc = ""]
    #[doc = "Subtract a number of bytes from a bufferevent's read or write bucket."]
    #[doc = "The decrement value can be negative, if you want to manually refill"]
    #[doc = "the bucket.\tIf the change puts the bucket above or below zero, the"]
    #[doc = "bufferevent will resume or suspend reading writing as appropriate."]
    #[doc = "These functions make no change in the buckets for the bufferevent's"]
    #[doc = "group, if any."]
    #[doc = ""]
    #[doc = "Returns 0 on success, -1 on internal error."]
    #[doc = ""]
    #[doc = "@{"]
    pub fn bufferevent_decrement_read_limit(
        bev: *mut bufferevent,
        decr: ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bufferevent_decrement_write_limit(
        bev: *mut bufferevent,
        decr: ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@name Group rate limit manipulation"]
    #[doc = ""]
    #[doc = "Subtract a number of bytes from a bufferevent rate-limiting group's"]
    #[doc = "read or write bucket.  The decrement value can be negative, if you"]
    #[doc = "want to manually refill the bucket.\tIf the change puts the bucket"]
    #[doc = "above or below zero, the bufferevents in the group will resume or"]
    #[doc = "suspend reading writing as appropriate."]
    #[doc = ""]
    #[doc = "Returns 0 on success, -1 on internal error."]
    #[doc = ""]
    #[doc = "@{"]
    pub fn bufferevent_rate_limit_group_decrement_read(
        arg1: *mut bufferevent_rate_limit_group,
        arg2: ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bufferevent_rate_limit_group_decrement_write(
        arg1: *mut bufferevent_rate_limit_group,
        arg2: ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inspect the total bytes read/written on a group."]
    #[doc = ""]
    #[doc = " Set the variable pointed to by total_read_out to the total number of bytes"]
    #[doc = " ever read on grp, and the variable pointed to by total_written_out to the"]
    #[doc = " total number of bytes ever written on grp."]
    pub fn bufferevent_rate_limit_group_get_totals(
        grp: *mut bufferevent_rate_limit_group,
        total_read_out: *mut u64,
        total_written_out: *mut u64,
    );
}
extern "C" {
    #[doc = " Reset the total bytes read/written on a group."]
    #[doc = ""]
    #[doc = " Reset the number of bytes read or written on grp as given by"]
    #[doc = " bufferevent_rate_limit_group_reset_totals()."]
    pub fn bufferevent_rate_limit_group_reset_totals(grp: *mut bufferevent_rate_limit_group);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_watermark {
    pub low: size_t,
    pub high: size_t,
}
#[test]
fn bindgen_test_layout_event_watermark() {
    assert_eq!(
        ::std::mem::size_of::<event_watermark>(),
        16usize,
        concat!("Size of: ", stringify!(event_watermark))
    );
    assert_eq!(
        ::std::mem::align_of::<event_watermark>(),
        8usize,
        concat!("Alignment of ", stringify!(event_watermark))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_watermark>())).low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_watermark),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_watermark>())).high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_watermark),
            "::",
            stringify!(high)
        )
    );
}
#[doc = "An opaque type for handling buffered IO"]
#[doc = ""]
#[doc = "@see event2/bufferevent.h"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bufferevent {
    #[doc = " Event base for which this bufferevent was created."]
    pub ev_base: *mut event_base,
    #[doc = " Pointer to a table of function pointers to set up how this"]
    #[doc = "bufferevent behaves."]
    pub be_ops: *mut bufferevent_ops,
    #[doc = " A read event that triggers when a timeout has happened or a socket"]
    #[doc = "is ready to read data.  Only used by some subtypes of"]
    #[doc = "bufferevent."]
    pub ev_read: event,
    #[doc = " A write event that triggers when a timeout has happened or a socket"]
    #[doc = "is ready to write data.  Only used by some subtypes of"]
    #[doc = "bufferevent."]
    pub ev_write: event,
    #[doc = " An input buffer. Only the bufferevent is allowed to add data to"]
    #[doc = "this buffer, though the user is allowed to drain it."]
    pub input: *mut evbuffer,
    #[doc = " An input buffer. Only the bufferevent is allowed to drain data"]
    #[doc = "from this buffer, though the user is allowed to add it."]
    pub output: *mut evbuffer,
    pub wm_read: event_watermark,
    pub wm_write: event_watermark,
    pub readcb: bufferevent_data_cb,
    pub writecb: bufferevent_data_cb,
    pub errorcb: bufferevent_event_cb,
    pub cbarg: *mut ::std::os::raw::c_void,
    pub timeout_read: timeval,
    pub timeout_write: timeval,
    #[doc = " Events that are currently enabled: currently EV_READ and EV_WRITE"]
    #[doc = "are supported."]
    pub enabled: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_bufferevent() {
    assert_eq!(
        ::std::mem::size_of::<bufferevent>(),
        392usize,
        concat!("Size of: ", stringify!(bufferevent))
    );
    assert_eq!(
        ::std::mem::align_of::<bufferevent>(),
        8usize,
        concat!("Alignment of ", stringify!(bufferevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).ev_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(ev_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).be_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(be_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).ev_read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(ev_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).ev_write as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(ev_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).input as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).output as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).wm_read as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(wm_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).wm_write as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(wm_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).readcb as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(readcb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).writecb as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(writecb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).errorcb as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(errorcb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).cbarg as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(cbarg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).timeout_read as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(timeout_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).timeout_write as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(timeout_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bufferevent>())).enabled as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(enabled)
        )
    );
}
extern "C" {
    #[doc = "Create a new bufferevent for an fd."]
    #[doc = ""]
    #[doc = "This function is deprecated.  Use bufferevent_socket_new and"]
    #[doc = "bufferevent_set_callbacks instead."]
    #[doc = ""]
    #[doc = "Libevent provides an abstraction on top of the regular event callbacks."]
    #[doc = "This abstraction is called a buffered event.  A buffered event provides"]
    #[doc = "input and output buffers that get filled and drained automatically.  The"]
    #[doc = "user of a buffered event no longer deals directly with the I/O, but"]
    #[doc = "instead is reading from input and writing to output buffers."]
    #[doc = ""]
    #[doc = "Once initialized, the bufferevent structure can be used repeatedly with"]
    #[doc = "bufferevent_enable() and bufferevent_disable()."]
    #[doc = ""]
    #[doc = "When read enabled the bufferevent will try to read from the file descriptor"]
    #[doc = "and call the read callback.  The write callback is executed whenever the"]
    #[doc = "output buffer is drained below the write low watermark, which is 0 by"]
    #[doc = "default."]
    #[doc = ""]
    #[doc = "If multiple bases are in use, bufferevent_base_set() must be called before"]
    #[doc = "enabling the bufferevent for the first time."]
    #[doc = ""]
    #[doc = "@deprecated This function is deprecated because it uses the current"]
    #[doc = "event base, and as such can be error prone for multithreaded programs."]
    #[doc = "Use bufferevent_socket_new() instead."]
    #[doc = ""]
    #[doc = "@param fd the file descriptor from which data is read and written to."]
    #[doc = "This file descriptor is not allowed to be a pipe(2)."]
    #[doc = "@param readcb callback to invoke when there is data to be read, or NULL if"]
    #[doc = "no callback is desired"]
    #[doc = "@param writecb callback to invoke when the file descriptor is ready for"]
    #[doc = "writing, or NULL if no callback is desired"]
    #[doc = "@param errorcb callback to invoke when there is an error on the file"]
    #[doc = "descriptor"]
    #[doc = "@param cbarg an argument that will be supplied to each of the callbacks"]
    #[doc = "(readcb, writecb, and errorcb)"]
    #[doc = "@return a pointer to a newly allocated bufferevent struct, or NULL if an"]
    #[doc = "error occurred"]
    #[doc = "@see bufferevent_base_set(), bufferevent_free()"]
    pub fn bufferevent_new(
        fd: ::std::os::raw::c_int,
        readcb: bufferevent_data_cb,
        writecb: bufferevent_data_cb,
        errorcb: bufferevent_event_cb,
        cbarg: *mut ::std::os::raw::c_void,
    ) -> *mut bufferevent;
}
extern "C" {
    #[doc = "Set the read and write timeout for a buffered event."]
    #[doc = ""]
    #[doc = "@param bufev the bufferevent to be modified"]
    #[doc = "@param timeout_read the read timeout"]
    #[doc = "@param timeout_write the write timeout"]
    pub fn bufferevent_settimeout(
        bufev: *mut bufferevent,
        timeout_read: ::std::os::raw::c_int,
        timeout_write: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn evtag_init();
}
extern "C" {
    #[doc = "Unmarshals the header and returns the length of the payload"]
    #[doc = ""]
    #[doc = "@param evbuf the buffer from which to unmarshal data"]
    #[doc = "@param ptag a pointer in which the tag id is being stored"]
    #[doc = "@returns -1 on failure or the number of bytes in the remaining payload."]
    pub fn evtag_unmarshal_header(evbuf: *mut evbuffer, ptag: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_marshal(
        evbuf: *mut evbuffer,
        tag: u32,
        data: *const ::std::os::raw::c_void,
        len: u32,
    );
}
extern "C" {
    pub fn evtag_marshal_buffer(evbuf: *mut evbuffer, tag: u32, data: *mut evbuffer);
}
extern "C" {
    #[doc = "Encode an integer and store it in an evbuffer."]
    #[doc = ""]
    #[doc = "We encode integers by nybbles; the first nibble contains the number"]
    #[doc = "of significant nibbles - 1;  this allows us to encode up to 64-bit"]
    #[doc = "integers.  This function is byte-order independent."]
    #[doc = ""]
    #[doc = "@param evbuf evbuffer to store the encoded number"]
    #[doc = "@param number a 32-bit integer"]
    pub fn evtag_encode_int(evbuf: *mut evbuffer, number: u32);
}
extern "C" {
    pub fn evtag_encode_int64(evbuf: *mut evbuffer, number: u64);
}
extern "C" {
    pub fn evtag_marshal_int(evbuf: *mut evbuffer, tag: u32, integer: u32);
}
extern "C" {
    pub fn evtag_marshal_int64(evbuf: *mut evbuffer, tag: u32, integer: u64);
}
extern "C" {
    pub fn evtag_marshal_string(
        buf: *mut evbuffer,
        tag: u32,
        string: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn evtag_marshal_timeval(evbuf: *mut evbuffer, tag: u32, tv: *mut timeval);
}
extern "C" {
    pub fn evtag_unmarshal(
        src: *mut evbuffer,
        ptag: *mut u32,
        dst: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_peek(evbuf: *mut evbuffer, ptag: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_peek_length(evbuf: *mut evbuffer, plength: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_payload_length(evbuf: *mut evbuffer, plength: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_consume(evbuf: *mut evbuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_int(
        evbuf: *mut evbuffer,
        need_tag: u32,
        pinteger: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_int64(
        evbuf: *mut evbuffer,
        need_tag: u32,
        pinteger: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_fixed(
        src: *mut evbuffer,
        need_tag: u32,
        data: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_string(
        evbuf: *mut evbuffer,
        need_tag: u32,
        pstring: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_timeval(
        evbuf: *mut evbuffer,
        need_tag: u32,
        ptv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_st {
    _unused: [u8; 0],
}
pub const bufferevent_ssl_state_BUFFEREVENT_SSL_OPEN: bufferevent_ssl_state = 0;
pub const bufferevent_ssl_state_BUFFEREVENT_SSL_CONNECTING: bufferevent_ssl_state = 1;
pub const bufferevent_ssl_state_BUFFEREVENT_SSL_ACCEPTING: bufferevent_ssl_state = 2;
#[doc = "The state of an SSL object to be used when creating a new"]
#[doc = "SSL bufferevent."]
pub type bufferevent_ssl_state = u32;
extern "C" {
    #[doc = "Create a new SSL bufferevent to send its data over another bufferevent."]
    #[doc = ""]
    #[doc = "@param base An event_base to use to detect reading and writing.  It"]
    #[doc = "must also be the base for the underlying bufferevent."]
    #[doc = "@param underlying A socket to use for this SSL"]
    #[doc = "@param ssl A SSL* object from openssl."]
    #[doc = "@param state The current state of the SSL connection"]
    #[doc = "@param options One or more bufferevent_options"]
    #[doc = "@return A new bufferevent on success, or NULL on failure"]
    pub fn bufferevent_openssl_filter_new(
        base: *mut event_base,
        underlying: *mut bufferevent,
        ssl: *mut ssl_st,
        state: bufferevent_ssl_state,
        options: ::std::os::raw::c_int,
    ) -> *mut bufferevent;
}
extern "C" {
    #[doc = "Create a new SSL bufferevent to send its data over an SSL * on a socket."]
    #[doc = ""]
    #[doc = "@param base An event_base to use to detect reading and writing"]
    #[doc = "@param fd A socket to use for this SSL"]
    #[doc = "@param ssl A SSL* object from openssl."]
    #[doc = "@param state The current state of the SSL connection"]
    #[doc = "@param options One or more bufferevent_options"]
    #[doc = "@return A new bufferevent on success, or NULL on failure."]
    pub fn bufferevent_openssl_socket_new(
        base: *mut event_base,
        fd: ::std::os::raw::c_int,
        ssl: *mut ssl_st,
        state: bufferevent_ssl_state,
        options: ::std::os::raw::c_int,
    ) -> *mut bufferevent;
}
extern "C" {
    #[doc = " Control how to report dirty SSL shutdowns."]
    #[doc = ""]
    #[doc = "If the peer (or the network, or an attacker) closes the TCP"]
    #[doc = "connection before closing the SSL channel, and the protocol is SSL >= v3,"]
    #[doc = "this is a \"dirty\" shutdown.  If allow_dirty_shutdown is 0 (default),"]
    #[doc = "this is reported as BEV_EVENT_ERROR."]
    #[doc = ""]
    #[doc = "If instead allow_dirty_shutdown=1, a dirty shutdown is reported as"]
    #[doc = "BEV_EVENT_EOF."]
    #[doc = ""]
    #[doc = "(Note that if the protocol is < SSLv3, you will always receive"]
    #[doc = "BEV_EVENT_EOF, since SSL 2 and earlier cannot distinguish a secure"]
    #[doc = "connection close from a dirty one.  This is one reason (among many)"]
    #[doc = "not to use SSL 2.)"]
    pub fn bufferevent_openssl_get_allow_dirty_shutdown(
        bev: *mut bufferevent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bufferevent_openssl_set_allow_dirty_shutdown(
        bev: *mut bufferevent,
        allow_dirty_shutdown: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Return the underlying openssl SSL * object for an SSL bufferevent."]
    pub fn bufferevent_openssl_get_ssl(bufev: *mut bufferevent) -> *mut ssl_st;
}
extern "C" {
    #[doc = " Tells a bufferevent to begin SSL renegotiation."]
    pub fn bufferevent_ssl_renegotiate(bev: *mut bufferevent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the most recent OpenSSL error reported on an SSL bufferevent."]
    pub fn bufferevent_get_openssl_error(bev: *mut bufferevent) -> ::std::os::raw::c_ulong;
}
#[doc = " This structure describes the interface a threading library uses for"]
#[doc = " locking.   It's used to tell evthread_set_lock_callbacks() how to use"]
#[doc = " locking on this platform."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evthread_lock_callbacks {
    #[doc = " The current version of the locking API.  Set this to"]
    #[doc = " EVTHREAD_LOCK_API_VERSION"]
    pub lock_api_version: ::std::os::raw::c_int,
    #[doc = " Which kinds of locks does this version of the locking API"]
    #[doc = " support?  A bitfield of EVTHREAD_LOCKTYPE_RECURSIVE and"]
    #[doc = " EVTHREAD_LOCKTYPE_READWRITE."]
    #[doc = ""]
    #[doc = " (Note that RECURSIVE locks are currently mandatory, and"]
    #[doc = " READWRITE locks are not currently used.)"]
    pub supported_locktypes: ::std::os::raw::c_uint,
    #[doc = " Function to allocate and initialize new lock of type 'locktype'."]
    #[doc = " Returns NULL on failure."]
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(locktype: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Funtion to release all storage held in 'lock', which was created"]
    #[doc = " with type 'locktype'."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(lock: *mut ::std::os::raw::c_void, locktype: ::std::os::raw::c_uint),
    >,
    #[doc = " Acquire an already-allocated lock at 'lock' with mode 'mode'."]
    #[doc = " Returns 0 on success, and nonzero on failure."]
    pub lock: ::std::option::Option<
        unsafe extern "C" fn(
            mode: ::std::os::raw::c_uint,
            lock: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Release a lock at 'lock' using mode 'mode'.  Returns 0 on success,"]
    #[doc = " and nonzero on failure."]
    pub unlock: ::std::option::Option<
        unsafe extern "C" fn(
            mode: ::std::os::raw::c_uint,
            lock: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_evthread_lock_callbacks() {
    assert_eq!(
        ::std::mem::size_of::<evthread_lock_callbacks>(),
        40usize,
        concat!("Size of: ", stringify!(evthread_lock_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<evthread_lock_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(evthread_lock_callbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evthread_lock_callbacks>())).lock_api_version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(lock_api_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evthread_lock_callbacks>())).supported_locktypes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(supported_locktypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evthread_lock_callbacks>())).alloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evthread_lock_callbacks>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evthread_lock_callbacks>())).lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evthread_lock_callbacks>())).unlock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(unlock)
        )
    );
}
extern "C" {
    #[doc = " Sets a group of functions that Libevent should use for locking."]
    #[doc = " For full information on the required callback API, see the"]
    #[doc = " documentation for the individual members of evthread_lock_callbacks."]
    #[doc = ""]
    #[doc = " Note that if you're using Windows or the Pthreads threading library, you"]
    #[doc = " probably shouldn't call this function; instead, use"]
    #[doc = " evthread_use_windows_threads() or evthread_use_posix_threads() if you can."]
    pub fn evthread_set_lock_callbacks(
        arg1: *const evthread_lock_callbacks,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This structure describes the interface a threading library uses for"]
#[doc = " condition variables.  It's used to tell evthread_set_condition_callbacks"]
#[doc = " how to use locking on this platform."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evthread_condition_callbacks {
    #[doc = " The current version of the conditions API.  Set this to"]
    #[doc = " EVTHREAD_CONDITION_API_VERSION"]
    pub condition_api_version: ::std::os::raw::c_int,
    #[doc = " Function to allocate and initialize a new condition variable."]
    #[doc = " Returns the condition variable on success, and NULL on failure."]
    #[doc = " The 'condtype' argument will be 0 with this API version."]
    pub alloc_condition: ::std::option::Option<
        unsafe extern "C" fn(condtype: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Function to free a condition variable."]
    pub free_condition:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut ::std::os::raw::c_void)>,
    #[doc = " Function to signal a condition variable.  If 'broadcast' is 1, all"]
    #[doc = " threads waiting on 'cond' should be woken; otherwise, only on one"]
    #[doc = " thread is worken.  Should return 0 on success, -1 on failure."]
    #[doc = " This function will only be called while holding the associated"]
    #[doc = " lock for the condition."]
    pub signal_condition: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut ::std::os::raw::c_void,
            broadcast: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Function to wait for a condition variable.  The lock 'lock'"]
    #[doc = " will be held when this function is called; should be released"]
    #[doc = " while waiting for the condition to be come signalled, and"]
    #[doc = " should be held again when this function returns."]
    #[doc = " If timeout is provided, it is interval of seconds to wait for"]
    #[doc = " the event to become signalled; if it is NULL, the function"]
    #[doc = " should wait indefinitely."]
    #[doc = ""]
    #[doc = " The function should return -1 on error; 0 if the condition"]
    #[doc = " was signalled, or 1 on a timeout."]
    pub wait_condition: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut ::std::os::raw::c_void,
            lock: *mut ::std::os::raw::c_void,
            timeout: *const timeval,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_evthread_condition_callbacks() {
    assert_eq!(
        ::std::mem::size_of::<evthread_condition_callbacks>(),
        40usize,
        concat!("Size of: ", stringify!(evthread_condition_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<evthread_condition_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(evthread_condition_callbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evthread_condition_callbacks>())).condition_api_version
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(condition_api_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evthread_condition_callbacks>())).alloc_condition as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(alloc_condition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evthread_condition_callbacks>())).free_condition as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(free_condition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evthread_condition_callbacks>())).signal_condition as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(signal_condition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evthread_condition_callbacks>())).wait_condition as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(wait_condition)
        )
    );
}
extern "C" {
    #[doc = " Sets a group of functions that Libevent should use for condition variables."]
    #[doc = " For full information on the required callback API, see the"]
    #[doc = " documentation for the individual members of evthread_condition_callbacks."]
    #[doc = ""]
    #[doc = " Note that if you're using Windows or the Pthreads threading library, you"]
    #[doc = " probably shouldn't call this function; instead, use"]
    #[doc = " evthread_use_windows_threads() or evthread_use_pthreads() if you can."]
    pub fn evthread_set_condition_callbacks(
        arg1: *const evthread_condition_callbacks,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Sets the function for determining the thread id."]
    #[doc = ""]
    #[doc = "@param base the event base for which to set the id function"]
    #[doc = "@param id_fn the identify function Libevent should invoke to"]
    #[doc = "determine the identity of a thread."]
    pub fn evthread_set_id_callback(
        id_fn: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    );
}
extern "C" {
    #[doc = " Sets up Libevent for use with Pthreads locking and thread ID functions."]
    #[doc = "Unavailable if Libevent is not build for use with pthreads.  Requires"]
    #[doc = "libraries to link against Libevent_pthreads as well as Libevent."]
    #[doc = ""]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evthread_use_pthreads() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable debugging wrappers around the current lock callbacks.  If Libevent"]
    #[doc = " makes one of several common locking errors, exit with an assertion failure."]
    #[doc = ""]
    #[doc = " If you're going to call this function, you must do so before any locks are"]
    #[doc = " allocated."]
    pub fn evthread_enable_lock_debugging();
}
extern "C" {
    pub fn evthread_enable_lock_debuging();
}
extern "C" {
    #[doc = " Make sure it's safe to tell an event base to wake up from another thread"]
    #[doc = "or a signal handler."]
    #[doc = ""]
    #[doc = "You shouldn't need to call this by hand; configuring the base with thread"]
    #[doc = "support should be necessary and sufficient."]
    #[doc = ""]
    #[doc = "@return 0 on success, -1 on failure."]
    pub fn evthread_make_base_notifiable(base: *mut event_base) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[doc = " Pointer to a table of function pointers to set up how this"]
#[doc = "bufferevent behaves."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bufferevent_ops {
    pub _address: u8,
}
